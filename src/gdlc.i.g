/* *************************************************************************
                          gdlc.i.g 
the GDL interpreter
interprets the output of the treeparser/compiler
                             -------------------
    begin                : July 22 2002
    copyright            : (C) 2002 by Marc Schellens
    email                : m_schellens@hotmail.com
 ***************************************************************************/

/* *************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

header "post_include_cpp" {
    // gets inserted after the antlr generated includes in the cpp file
#include "dinterpreter.hpp"

using namespace std;
}

header {
#include <map>
#include <iomanip>
//#include <exception>

#include "datatypes.hpp"
#include "objects.hpp"
#include "dpro.hpp"
#include "dnode.hpp"
#include "accessdesc.hpp"
#include "initsysvar.hpp"
#include "gdljournal.hpp"
}

options {
	language="Cpp";
	genHashLines = false;
	namespaceStd="std";         // cosmetic option to get rid of long defines
	namespaceAntlr="antlr";     // cosmetic option to get rid of long defines
}	

// the GDL TreeParser  ****************************************
class GDLInterpreter extends TreeParser;

options {
  importVocab = GDL;	// use vocab generated by lexer
  buildAST = false;     // no modifying of AST anymore
  ASTLabelType = "RefDNode";
//  defaultErrorHandler = true;
  defaultErrorHandler = false;
}
{
public: 
    enum RetCode {
        RC_OK=0,
        RC_BREAK,
        RC_CONTINUE,
        RC_RETURN,
        RC_ABORT
    };  

    // code in: dinterpreter.cpp
    static bool SearchCompilePro(const std::string& pro);
    static int GetFunIx( const std::string& subName);
    static int GetProIx( const std::string& subName);
    DStructGDL* ObjectStruct( BaseGDL* self, RefDNode mp);
    DStructGDL* ObjectStructCheckAccess( BaseGDL* self, RefDNode mp);

private: 
    // code in: dinterpreter.cpp
    static void SetFunIx( RefDNode& f); // triggers read/compile
    static void SetProIx( RefDNode& f); // triggers read/compile
    static void AdjustTypes( BaseGDL*&, BaseGDL*&);


protected:
    std::istringstream executeLine; // actual interactive executed line

    class RetAllException {};
    
    // code in: dinterpreter.cpp
//    static bool CompleteFileName(std::string& fn); -> str.cpp
    static bool CompileFile(const std::string& f, const std::string& untilPro=""); 
    BaseGDL*  returnValue;  // holding the return value for functions
    BaseGDL** returnValueL; // holding the return value for l_functions

    // override method to gain speed (no checking needed in interpreter)
	void match(antlr::RefAST t, int ttype) {}

    bool interruptEnable;

    typedef std::map<SizeT, BaseGDL*> HeapT;
    typedef std::map<SizeT, DStructGDL*> ObjHeapT;

    // the following must be all static because several interpreter might be active
    // the heap for all dynamic variables
    // ease the handling, no memory leaks, gc possible
    static HeapT     heap; 
    static ObjHeapT  objHeap; 

    // index for newly allocated heap variables
    static SizeT objHeapIx;
    static SizeT heapIx;

    static EnvStackT  callStack; 

public:
    // triggers read/compile/interpret
    DStructDesc* GetStruct(const std::string& name, const RefDNode cN); 

    // the New... functions 'own' their BaseGDL*
    SizeT NewObjHeap( SizeT n=1, DStructGDL* var=NULL)
    {
        SizeT tmpIx=objHeapIx;
        for( SizeT i=0; i<n; i++)
        objHeap.insert( objHeap.end(),
            std::pair<SizeT, DStructGDL*>( objHeapIx++, var));
        return tmpIx;
    }
    SizeT NewHeap( SizeT n=1, BaseGDL* var=NULL)
    {
        SizeT tmpIx=heapIx;
        for( SizeT i=0; i<n; i++)
        heap.insert( heap.end(),
            std::pair<SizeT, BaseGDL*>( heapIx++, var));
        return tmpIx;
    }
    static void FreeObjHeap( DObj id)
    {
        if( id != 0)
        {       
            ObjHeapT::iterator it=objHeap.find( id);
            if  ( it != objHeap.end()) 
            { 
                delete (*it).second;
                objHeap.erase( id);
            }
        }
    }
    static void FreeHeap( DPtrGDL* p)
    {
        SizeT nEl=p->N_Elements();
        for( SizeT ix=0; ix < nEl; ix++)
        {
            DPtr id= (*p)[ix];
            if( id != 0)
            {
                HeapT::iterator it=heap.find( id);
                if( it != heap.end()) 
                { 
                    delete (*it).second;
                    heap.erase( id); 
                }
            }
        }
    }

    class HeapException {};

    static BaseGDL*& GetHeap( DPtr ID)
    {
        HeapT::iterator it=heap.find( ID);
        if( it == heap.end()) throw HeapException();
        return it->second;
    }
    static DStructGDL*& GetObjHeap( DObj ID)
    {
        ObjHeapT::iterator it=objHeap.find( ID);
        if( it == objHeap.end()) throw HeapException();
        return it->second;
    }

    static bool PtrValid( DPtr ID)
    {
        HeapT::iterator it=heap.find( ID);
        return  (it != heap.end());
    }

    static SizeT HeapSize()
    {
        return heap.size();
    }

    static DPtrGDL* GetAllHeap()
    {
        SizeT nEl = heap.size();
        if( nEl == 0) return new DPtrGDL( 0);
        DPtrGDL* ret = new DPtrGDL( dimension( &nEl, 1), BaseGDL::NOZERO);
        SizeT i=0;
        for( HeapT::iterator it=heap.begin(); it != heap.end(); ++it)
        {
            (*ret)[ i++] = it->first;
        }
        return ret;
    }

    static bool ObjValid( DObj ID)
    {
        ObjHeapT::iterator it=objHeap.find( ID);
        return  (it != objHeap.end());
    }

    static SizeT ObjHeapSize()
    {
        return objHeap.size();
    }

    static DObjGDL* GetAllObjHeap()
    {
        SizeT nEl = objHeap.size();
        if( nEl == 0) return new DObjGDL( 0);
        DObjGDL* ret = new DObjGDL( dimension( &nEl, 1), BaseGDL::NOZERO);
        SizeT i=0;
        for( ObjHeapT::iterator it=objHeap.begin(); it != objHeap.end(); ++it)
        {
            (*ret)[ i++] = it->first;
        }
        return ret;
    }

    // name of data
    static const std::string Name( BaseGDL* p) // const
    {
        return callStack.back()->GetString( p);
    }

    static const std::string Name( BaseGDL** p) // const
    {
        return "<(Find name not implemented yet)>";
    }

    // compiler (lexer, parser, treeparser) def in dinterpreter.cpp
    static void ReportCompileError( GDLException& e, const std::string& file = "");

    // interpreter
    static void ReportError( GDLException& e)
    {
        DString msgPrefix = SysVar::MsgPrefix();

        std::cout << std::flush;
        if( e.Prefix())
        {
            std::cerr << msgPrefix << e.toString() << std::endl;
            lib::write_journal_comment(msgPrefix+e.toString());
        }
        else
        {
            std::cerr << e.toString() << std::endl;
            lib::write_journal_comment(e.toString());
        }

        std::cerr << msgPrefix << "Execution halted at:  " << 
        std::left << std::setw(16) << callStack.back()->GetProName();
        std::string file=callStack.back()->GetFilename();
        if( file != "")
        {
            SizeT line = e.getLine();
            if( line != 0)
            {       
                std::cerr << std::right << std::setw(6) << line;
            }
            else
            {
                std::cerr << std::right << std::setw(6) << "";
            }
            std::cerr << std::left << " " << file;
        }
        std::cerr << std::endl;
        
        DumpStack();
    }
    
    static void DumpStack()
    {
        DString msgPrefix = SysVar::MsgPrefix();

        EnvStackT::reverse_iterator upEnv = callStack.rbegin();
        EnvStackT::reverse_iterator env = upEnv++;
        for(; 
            upEnv != callStack.rend();
            ++upEnv, ++env)
        {
            std::cerr << msgPrefix << "                      ";
            std::cerr << std::left << std::setw(16) << (*upEnv)->GetProName();

            std::string file = (*upEnv)->GetFilename();
            if( file != "")
            {
                RefDNode cNode= (*env)->CallingNode();
                if( cNode != static_cast<RefDNode>(antlr::nullAST))
                {       
                    std::cerr << std::right << std::setw(6) << cNode->getLine();
                }
                else
                {
                    std::cerr << std::right << std::setw(6) << "";
                }
                std::cerr << std::left << " " << file;
            }
            std::cerr << std::endl;
        }
    }

    static void DebugMsg( RefDNode _t, const std::string& msg)
    {    
        DString msgPrefix = SysVar::MsgPrefix();

        std::cout << std::flush;
        std::cerr << msgPrefix << msg
        << std::left << std::setw(16) << callStack.back()->GetProName();
        std::string file=callStack.back()->GetFilename();
        if( file != "")
        {
            RefDNode eNode = _t;
            if( eNode != static_cast<RefDNode>(antlr::nullAST))
            {       
                std::cerr << std::right << std::setw(6) << eNode->getLine();
            }
            else
            {
                std::cerr << std::right << std::setw(6) << "";
            }
            std::cerr << std::left << " " << file;
        }
        std::cerr << std::endl;
    }

    static void RetAll()
    {
        throw RetAllException();
    }

    static EnvStackT& CallStack() { return callStack;} // the callstack
    
    std::string GetClearActualLine()
    {
        std::string ret = executeLine.str();
        executeLine.str("");
        return ret;
    }

    ~GDLInterpreter()
    {
    }
}

//***********************************************************************
// interpreter functions ************************************************
//***********************************************************************

// intercative usage
interactive returns[ GDLInterpreter::RetCode retCode]
    : retCode=statement_list
    ;

// execute statement
execute
{
    GDLInterpreter::RetCode retCode;
    ValueGuard<bool> guard( interruptEnable);
    interruptEnable = false;
}
    : retCode=statement_list
    ;

// used to call functions
// same as statement list, but different behaviour for returncodes
call_fun returns[ BaseGDL* res]
{

    res = NULL;
    returnValue = NULL;
    GDLInterpreter::RetCode retCode;
}
    : (retCode=statement
            {
                if( retCode == RC_RETURN) 
                {
                    res=returnValue;
                    returnValue=NULL;
                    
                    break;
                }
            }
        )*
        {
            // default return value if none was set
            if( res == NULL) res = new DIntGDL( 0); 
        }
    ;

call_lfun returns[ BaseGDL** res]
{
    res = NULL;
    returnValueL = NULL;
    GDLInterpreter::RetCode retCode;
}
    : (retCode=statement
            {
                if( retCode == RC_RETURN) 
                {
                    res=returnValueL;
                    returnValueL=NULL;
                    break;
                }
            }
        )*
        {
            // default return value if none was set
            if( res == NULL)
            throw GDLException( call_lfun_AST_in, "Function "+
                callStack.back()->GetProName()+
                " must return a left-value in this context.");
        }
    ;

// used to call procedures
call_pro
{
    GDLInterpreter::RetCode retCode;
}
    : (retCode=statement
            {
                if( retCode == RC_RETURN) break;
            }
        )*
    ;

// used on many occasions
statement_list returns[ GDLInterpreter::RetCode retCode]
    : (retCode=statement
            {
                if( retCode != RC_OK) break; // break out if non-regular
            }
        )+
    ;

statement returns[ GDLInterpreter::RetCode retCode]
{
    retCode = RC_OK;
}
	: (
            // note: assignment must take care to update the owner of the lvalue
            // a real copy must be performed (creating a new BaseGDL)  
            assignment
        |   procedure_call
            //        |   lib_procedure_call
        |   decinc_statement
        |   retCode=for_statement 
        |   retCode=repeat_statement
        |   retCode=while_statement
        |   retCode=if_statement
        |   retCode=if_else_statement
        |   retCode=case_statement
        |   retCode=switch_statement
        |   retCode=block
        |   retCode=jump_statement
        |   LABEL
        |   ON_IOERROR_NULL
            {
                callStack.back()->SetIOError( -1);
            }
        |   o:ON_IOERROR
            {
                callStack.back()->SetIOError( o->targetIx);
            }
        )
        // control c and debugging
        {
           // possible optimization: make sigControlC a debugMode 
           if( interruptEnable && sigControlC)
            {
                DebugMsg( _t, "Interrupted at: "); 

                sigControlC = false;

                // only start new InterpreterLoop when not at $MAIN$
                if( callStack.size() > 1)
                {
                    DInterpreter* thisDInterpreter =
                        dynamic_cast<DInterpreter*>( this);
                    if( thisDInterpreter != NULL)
                        retCode = thisDInterpreter->InterpreterLoop();
                }
                else
                {
                    retCode = RC_ABORT;
                }
            }
            else if( debugMode != DEBUG_CLEAR)
            {
                if( debugMode == DEBUG_STOP)
                {
                    DebugMsg( _t, "Stop encoutered: ");
                    if( !interruptEnable)
                        debugMode = DEBUG_PROCESS_STOP;
                }

                if( interruptEnable)
                {
                    if( debugMode == DEBUG_PROCESS_STOP)
                    {
                        DebugMsg( _t, "Stepped to: ");
                    }

                    debugMode = DEBUG_CLEAR;
                
                    // only start new InterpreterLoop when not at $MAIN$
                    if( callStack.size() > 1)
                    {
                        DInterpreter* thisDInterpreter =
                        dynamic_cast<DInterpreter*>( this);
                        if( thisDInterpreter != NULL)
                        retCode = thisDInterpreter->InterpreterLoop();
                    }
                    else
                    {
                        retCode = RC_ABORT;
                    }
                }
                else
                {
                    retCode = RC_ABORT;
                }
            }
        }
	;
    exception 
    catch [ GDLException& e] 
    { 
        lib::write_journal( GetClearActualLine());

        // many low level routines don't have errorNode info
        // set line number here in this case
        if( e.getLine() == 0)
        {
            e.SetLine( _t->getLine());
        }

        ReportError(e); 

        // only start new InterpreterLoop when not at $MAIN$
        if( interruptEnable)
        {
            if( callStack.size() > 1)
            {
                DInterpreter* thisDInterpreter =
                dynamic_cast<DInterpreter*>( this);
                if( thisDInterpreter != NULL)
                retCode = thisDInterpreter->InterpreterLoop();
            }
            else
            {
                retCode = RC_ABORT;
                // here the statement is already executed
                _t = statement_AST_in->GetNextSibling();
            }
        }    
        else
        {
            retCode = RC_ABORT;
        }
    }

block returns[ GDLInterpreter::RetCode retCode]
{
    retCode = RC_OK;
}
	: #(BLOCK (retCode=statement_list)?)
	;

switch_statement returns[ GDLInterpreter::RetCode retCode]
{
    BaseGDL* e;
    retCode = RC_OK; // not set if no branch is executed
}
	: #(s:SWITCH e=expr 
            {
                auto_ptr<BaseGDL> e_guard(e);
                
                SizeT nJump = callStack.back()->NJump();

                RefDNode b=_t; // remeber block begin (block)

                bool hook=false; // switch executes everything after 1st match
                for( int i=0; i<s->numBranch; i++)
                {
                    if( b->getType() == ELSEBLK)
                    {
                        hook=true;

                        RefDNode sL = b->GetFirstChild(); // statement_list

                        if( sL != static_cast<RefDNode>(antlr::nullAST) )
                        {
                            // statement there
                            retCode=statement_list( sL);
                            if( retCode == RC_BREAK) 
                            {
                                retCode = RC_OK;    
                                break;          // break
                            }
                            if( retCode >= RC_RETURN) break; // goto

                            if( (callStack.back()->NJump() != nJump) &&
                                !s->LabelInRange( callStack.back()->LastJump()))
                            {
                                // a jump (goto) occured out of this loop
                                return retCode;
                            }

                        }
                    }
                    else
                    {
                        RefDNode ex = b->GetFirstChild();  // EXPR
                        RefDNode bb = ex->GetNextSibling(); // statement_list

                        if( !hook)
                        {
//                            RefDNode ee_ = _t->GetFirstChild(); // expr

                            BaseGDL* ee=expr(ex);
                            // auto_ptr<BaseGDL> ee_guard(ee);

                            hook=e->Equal(ee); // Equal deletes ee
                        }
                            
                        if(bb != static_cast<RefDNode>(antlr::nullAST) && hook)
                        {
                            // statement there
                            retCode=statement_list(bb);
                            if( retCode == RC_BREAK) 
                            {
                                retCode = RC_OK;    
                                break;          // break
                            }
                            if( retCode >= RC_RETURN) break; // goto

                            if( (callStack.back()->NJump() != nJump) &&
                                !s->LabelInRange( callStack.back()->LastJump()))
                            {
                                // a jump (goto) occured out of this loop
                                return retCode;
                            }
                        }
                        
                    }
                    b=b->GetNextSibling(); // next block
                }
                // finish or break
//                retCode=RC_OK; // clear RC_BREAK retCode
            }
        )
    ;

case_statement returns[ GDLInterpreter::RetCode retCode]
{
    BaseGDL* e;
    retCode = RC_OK; // not set if no branch is executed
}
	: #(c:CASE e=expr
            {
                auto_ptr<BaseGDL> e_guard(e);

                SizeT nJump = callStack.back()->NJump();

                if( !e->Scalar())
                throw GDLException( _t, "Expression must be a"
                    " scalar in this context: "+Name(e));

                RefDNode b=_t; // remeber block begin

                for( int i=0; i<c->numBranch; i++)
                {
                    if( b->getType() == ELSEBLK)
                    {
                        RefDNode sL = b->GetFirstChild(); // statement_list

                        if(sL != static_cast<RefDNode>(antlr::nullAST) )
                        {
                            // statement there
                            retCode=statement_list(sL);
                            //if( retCode == RC_BREAK) break; // break anyway
//                            if( retCode >= RC_RETURN) return retCode; 
                            if( retCode >= RC_RETURN) break;
                            
                            if( (callStack.back()->NJump() != nJump) &&
                                !c->LabelInRange( callStack.back()->LastJump()))
                            {
                                // a jump (goto) occured out of this loop
                                return retCode;
                            }

                        }
                        retCode = RC_OK;
                        break;
                    }
                    else
                    {
                        RefDNode ex = b->GetFirstChild();  // EXPR
                        RefDNode bb = ex->GetNextSibling(); // statement_list

                        BaseGDL* ee=expr(ex);
                        // auto_ptr<BaseGDL> ee_guard(ee);

                        bool equalexpr=e->Equal(ee); // Equal deletes ee

                        if( equalexpr)
                        {
                            if(_t != static_cast<RefDNode>(antlr::nullAST))
                            {
                                // statement there
                                retCode=statement_list(bb);
                                //if( retCode == RC_BREAK) break; // break anyway
//                                if( retCode >= RC_RETURN) return retCode;
                                if( retCode >= RC_RETURN) break;

                                if( (callStack.back()->NJump() != nJump) &&
                                    !c->LabelInRange( callStack.back()->LastJump()))
                                {
                                    // a jump (goto) occured out of this loop
                                    return retCode;
                                }

                            }
                            retCode = RC_OK;
                            break;
                        }
                        
                    }
                    b=b->GetNextSibling(); // next block
                }
                // finish or break
//                retCode=RC_OK; // clear RC_BREAK retCode
            }
        )
	;

repeat_statement returns[ GDLInterpreter::RetCode retCode]
	: #(r:REPEAT // block expr
            {
                SizeT nJump = callStack.back()->NJump();

                // remember block and expr nodes
                RefDNode bb =_t;
                RefDNode e  = bb->GetNextSibling();
                
                auto_ptr<BaseGDL> eVal;
                do {
                    retCode=block(bb);

                    if( retCode == RC_CONTINUE) continue;  
                    if( retCode == RC_BREAK) 
                    {
                        retCode = RC_OK;
                        break;        
                    }
                    if( retCode >= RC_RETURN) break;
                    // if( retCode == RC_BREAK) break;        
                    // if( retCode >= RC_RETURN) return retCode;

                    if( (callStack.back()->NJump() != nJump) &&
                        !r->LabelInRange( callStack.back()->LastJump()))
                    {
                        // a jump (goto) occured out of this loop
                        return retCode;
                    }

                    eVal.reset( expr(e));
                } while( eVal.get()->False());
                
                // retCode=RC_OK; // clear RC_BREAK/RC_CONTINUE retCode
            }
        )
	;

while_statement returns[ GDLInterpreter::RetCode retCode]
{
    retCode = RC_OK;
}
	: #(w:WHILE // statement expr 
            {
                SizeT nJump = callStack.back()->NJump();

                RefDNode s = _t; //->GetFirstChild();  // statement
                RefDNode e =  s->GetNextSibling(); // expr

                auto_ptr< BaseGDL> eVal( expr( e));
                while( eVal.get()->True()) {
                    retCode=statement(s);

                    if( retCode == RC_CONTINUE) continue;  
                    if( retCode == RC_BREAK) 
                    {
                        retCode = RC_OK;
                        break;        
                    }
                    if( retCode >= RC_RETURN) break;
                    
                    if( (callStack.back()->NJump() != nJump) &&
                        !w->LabelInRange( callStack.back()->LastJump()))
                    {
                        // a jump (goto) occured out of this loop
                        return retCode;
                    }

                    eVal.reset( expr( e));
                } 

                // retCode=RC_OK; // clear RC_BREAK/RC_CONTINUE retCode
            }
        )
	;

for_statement returns[ GDLInterpreter::RetCode retCode]
{
    BaseGDL** v;
    BaseGDL* s;
    BaseGDL* e;
    BaseGDL* st;
    retCode = RC_OK;
}
    : #(f:FOR // (VAR|VARPTR) expr expr 
            v=l_simple_var
            s=expr e=expr
            {
                auto_ptr<BaseGDL> s_guard(s);
                auto_ptr<BaseGDL> e_guard(e);

                SizeT nJump = callStack.back()->NJump();

                s->ForCheck( &e);
                e_guard.release();
                e_guard.reset(e);

                RefDNode b=_t;
                
                // ASSIGNMENT used here also
                delete (*v);

                s_guard.release(); // s now hold in *v
                for((*v)=s; (*v)->ForCondUp( e); (*v)->ForAdd()) 
                {
                    retCode=block(b);
                    
                    if( retCode == RC_CONTINUE) continue;  
                    if( retCode == RC_BREAK) 
                    {
                        retCode = RC_OK;
                        break;        
                    }
                    if( retCode >= RC_RETURN) break;

                    if( (callStack.back()->NJump() != nJump) &&
                        !f->LabelInRange( callStack.back()->LastJump()))
                    {
                        // a jump (goto) occured out of this loop
                        return retCode;
                    }
                }
                retCode=RC_OK; // clear RC_BREAK/RC_CONTINUE retCode
            }
        )
    | #(fs:FOR_STEP // (VAR|VARPTR) expr expr expr 
            v=l_simple_var
            s=expr e=expr st=expr
            {
                auto_ptr<BaseGDL> s_guard(s);
                auto_ptr<BaseGDL> e_guard(e);
                auto_ptr<BaseGDL> st_guard(st);

                SizeT nJump = callStack.back()->NJump();

                s->ForCheck( &e, &st);
                e_guard.release();
                e_guard.reset(e);
                st_guard.release();
                st_guard.reset(st);
                
                RefDNode bs=_t;
                
                // ASSIGNMENT used here also
                delete (*v);
                
                if( st->Sgn() == -1) 
                {
                    s_guard.release();
                    for((*v)=s; (*v)->ForCondDown( e); (*v)->ForAdd(st))
                    {
                        retCode=block(bs);
                        
                        if( retCode == RC_CONTINUE) continue;  
                        if( retCode == RC_BREAK) 
                        {
                            retCode = RC_OK;
                            break;        
                        }
                        if( retCode >= RC_RETURN) break;

                        if( (callStack.back()->NJump() != nJump) &&
                            !fs->LabelInRange( callStack.back()->LastJump()))
                        {
                            // a jump (goto) occured out of this loop
                            return retCode;
                        }
                    }
                } 
                else
                {
                    s_guard.release();
                    for((*v)=s; (*v)->ForCondUp( e); (*v)->ForAdd(st))
                    {
                        retCode=block(bs);
                        
                        if( retCode == RC_CONTINUE) continue;  
                        if( retCode == RC_BREAK) 
                        {
                            retCode = RC_OK;
                            break;        
                        }
                        if( retCode >= RC_RETURN) break;

                        if( (callStack.back()->NJump() != nJump) &&
                            !fs->LabelInRange( callStack.back()->LastJump()))
                        {
                            // a jump (goto) occured out of this loop
                            return retCode;
                        }
                    }
                }
            }
        )
	;

if_statement returns[ GDLInterpreter::RetCode retCode]
{
    BaseGDL* e;
    retCode = RC_OK; // not set if not executed
}
	: #(i:IF e=expr
            { 
                auto_ptr<BaseGDL> e_guard(e);

                SizeT nJump = callStack.back()->NJump();

                if( e->True())
                {
                    retCode=statement(_t);
//                    if( retCode != RC_OK) return retCode;

                        if( (callStack.back()->NJump() != nJump) &&
                            !i->LabelInRange( callStack.back()->LastJump()))
                        {
                            // a jump (goto) occured out of this loop
                            return retCode;
                        }
                }
            }
        )
	;   

if_else_statement returns[ GDLInterpreter::RetCode retCode]
{
    BaseGDL* e;
}
	: #(i:IF_ELSE e=expr
            { 
                auto_ptr<BaseGDL> e_guard(e);

                SizeT nJump = callStack.back()->NJump();

                if( e->True())
                {
                    retCode=statement(_t);
//                    if( retCode != RC_OK) return retCode;

                    if( (callStack.back()->NJump() != nJump) &&
                        !i->LabelInRange( callStack.back()->LastJump()))
                    {
                        // a jump (goto) occured out of this loop
                        return retCode;
                    }
                }
                else
                {
                    _t=_t->GetNextSibling(); // jump over 1st statement
                    retCode=statement(_t);
//                    if( retCode != RC_OK) return retCode;

                    if( (callStack.back()->NJump() != nJump) &&
                        !i->LabelInRange( callStack.back()->LastJump()))
                    {
                        // a jump (goto) occured out of this loop
                        return retCode;
                    }
                }
            }
        )
	;   

// to be processed (to make sure it really returns)
jump_statement returns[ GDLInterpreter::RetCode retCode]
{
BaseGDL*  e;
BaseGDL** eL;
}
    : g:GOTO // target in g->gotoTarget; // pointer to an DNode (NO RefDNode)
        {
            // note that this version jumps 'dumb'
            // jumping into loops is legal, even then looping is not done

            // set the jump target - also logs the jump
            _t = callStack.back()->GotoTarget( g->targetIx);
            _t = _t->GetNextSibling();
            retCode=RC_OK;
        }
    | #(RETF ( { !callStack.back()->LFun()}? e=expr // expr -> r value
                {
                    delete returnValue;
                    returnValue=e;
                    retCode=RC_RETURN;
                    callStack.back()->RemoveLoc( e); // steal e from local list
                }
            | eL=l_ret_expr
                {
                    // returnValueL is otherwise owned
                    returnValueL=eL;
                    retCode=RC_RETURN;
                }
            )
        ) 
    | RETP
        {
            retCode=RC_RETURN;
        }
	| BREAK    // only in loops or switch_statement and case_statement
        {
            retCode=RC_BREAK;
        }
	| CONTINUE // only in loops
        {
            retCode=RC_CONTINUE;
        }
  ;

procedure_call
{ 
    // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
    StackGuard<EnvStackT> guard(callStack);
    BaseGDL *self;
    EnvT*   newEnv;
}
	: #(PCALL_LIB pl:IDENTIFIER
            {
                EnvT* newEnv=new EnvT( this, pl, libProList[pl->proIx]);
            }
            parameter_def[ newEnv]
            {
                // push environment onto call stack
                callStack.push_back(newEnv);

                // make the call
                static_cast<DLibPro*>(newEnv->GetPro())->Pro()(newEnv);
            }   
        )
    |
        (
        ( #(MPCALL 
                self=expr mp:IDENTIFIER
                {  
                    auto_ptr<BaseGDL> self_guard(self);
                    
                    newEnv=new EnvT( this, mp, self);

                    self_guard.release();
                }
                parameter_def[ newEnv]
            )
        | #(MPCALL_PARENT 
                self=expr parent:IDENTIFIER pp:IDENTIFIER
                {
                    auto_ptr<BaseGDL> self_guard(self);
                    
                    newEnv = new EnvT( this, pp, self, parent->getText());

                    self_guard.release();
                }
                parameter_def[ newEnv]
            )
        | #(PCALL p:IDENTIFIER
            {
                SetProIx( p);
            
                newEnv = new EnvT( this, p, proList[p->proIx]);
            }
            parameter_def[ newEnv]
            )
        )
        {
            // push environment onto call stack
            callStack.push_back(newEnv);
            
            // make the call
            call_pro(static_cast<DSubUD*>(newEnv->GetPro())->GetTree());
        }   
        )
	;	

assignment
{
    BaseGDL*  r;
    BaseGDL** l;
    auto_ptr<BaseGDL> r_guard;
}
    : #(a:ASSIGN 
            ( r=tmp_expr
                {
                    r_guard.reset( r);
                }
            | r=check_expr
                {
                    if( !callStack.back()->Contains( r)) 
                        r_guard.reset( r);
                }
            )
            l=l_expr[ r]
//             {
//                 // no delete if assigned to itself
//                 // only possible from lib function
//                 if( (*l) == r || callStack.back()->Contains( r)) 
//                     r_guard.release();
//             }
        )
    ;

decinc_statement
{
    BaseGDL* l;
}
    : #(DEC l=l_decinc_expr[ DECSTATEMENT])
    | #(INC l=l_decinc_expr[ INCSTATEMENT])
    ;

// ***************************************************************************
// the expressions ***********************************************************
// ***************************************************************************

l_deref returns [BaseGDL** res]
{
    BaseGDL*       e1;
}
    : #(DEREF e1=expr 
            {
                auto_ptr<BaseGDL> e1_guard(e1);
                
                DPtrGDL* ptr=dynamic_cast<DPtrGDL*>(e1);
                if( ptr == NULL)
                throw GDLException( _t, "Pointer type required"
                    " in this context: "+Name(e1));
                DPtr sc; 
                if( !ptr->Scalar(sc))
                throw GDLException( _t, "Expression must be a "
                    "scalar in this context: "+Name(e1));
                if( sc == 0)
                throw GDLException( _t, "Unable to dereference"
                    " NULL pointer: "+Name(e1));
                
                try{
                    res = &GetHeap(sc);
                }
                catch( HeapException)
                {
                    throw GDLException( _t, "Invalid pointer: "+Name(e1));
                }
            }
        )
    ;

// return value from functions when used as l var
// used only from jump_statement and within itself
l_ret_expr returns [BaseGDL** res]
{
    BaseGDL*       e1;
}
    : res=l_deref
    | #(QUESTION e1=expr
            { 
                auto_ptr<BaseGDL> e1_guard(e1);
                if( e1->True())
                {
                    res=l_ret_expr(_t);
                }
                else
                {
                    _t=_t->GetNextSibling(); // jump over 1st expression
                    res=l_ret_expr(_t);
                }
            }
        ) // trinary operator
//    | #(EXPR res=l_ret_expr) // does not exist anymore
    | res=l_function_call 
        { // here a local to the actual environment could be returned
            if( callStack.back()->IsLocalKW( res))
            throw GDLException( _t, 
                "Attempt to return indirectly a local variable "
                "from left-function.");
        }
    | varPtr:VARPTR // DNode.var   is ptr to common block variable
        {
            res=&varPtr->var->Data(); // returns BaseGDL* of var (DVar*) 
        }
    | var:VAR // DNode.varIx is index into functions/procedures environment
        {     // check if variable is non-local 
              // (because it will be invalid after return otherwise)
            if( !callStack.back()->GlobalKW(var->varIx))
            throw GDLException( _t, 
                "Attempt to return a non-global variable from left-function.");
            
            res=&callStack.back()->GetKW(var->varIx); 
        }
    | #(ASSIGN 
            { 
                auto_ptr<BaseGDL> r_guard;
            } 
            ( e1=tmp_expr
                {
                    r_guard.reset( e1);
                }
            | e1=check_expr
                {
                    if( !callStack.back()->Contains( e1)) 
                        r_guard.reset( e1);
                }
            )
            res=l_ret_expr
            {
                if( e1 != (*res))
                    {
                    delete *res;
                    *res = e1;
                    }
                r_guard.release();
            }
        )

    // the following are forbiden    
    | #(ARRAYEXPR
            {
                throw GDLException( _t, 
                    "Indexed expression not allowed as left-function"
                    " return value.");
            }
        )
    | #(DOT 
            {
                throw GDLException( _t, 
                    "Struct expression not allowed as left-function"
                    " return value.");
            }
        )
    | SYSVAR
        {
            throw GDLException( _t, 
                "System variable not allowed as left-function"
                " return value.");
        }
    | e1=r_expr
        {
            delete e1;
            throw GDLException( _t, 
                "Expression not allowed as left-function return value.");
        }
    ;

// l expressions for DEC/INC ********************************
// called from l_decinc_array_expr
l_decinc_indexable_expr [int dec_inc] returns [BaseGDL* res]
{
    BaseGDL** e;
}
//     : #(EXPR e = l_expr[ NULL])                       
//         {
//             res = *e;
//             if( res == NULL)
//             throw GDLException( _t, "Variable is undefined: "+Name(e));
//         }
//     | e=l_function_call
    : e=l_function_call
        {
            res = *e;
            if( res == NULL)
            throw GDLException( _t, "Variable is undefined: "+Name(e));
        }
    | e=l_deref 
        {
            res = *e;
            if( res == NULL)
            throw GDLException( _t, "Variable is undefined: "+Name(e));
        }
    | e=l_defined_simple_var { res = *e; } // no Dup here
    | e=l_sys_var { res = *e; }            // no Dup here
    ;

// called from l_decinc_expr
l_decinc_array_expr [int dec_inc] returns [BaseGDL* res]
{
    ArrayIndexListT* aL;
    BaseGDL*         e;
    auto_ptr<ArrayIndexListT> guard;

}
    : #(ARRAYEXPR 
            aL=arrayindex_list 
            { guard.reset( aL);} 
            e=l_decinc_indexable_expr[ dec_inc])   
        {
            aL->SetVariable( e);

            if( dec_inc == DECSTATEMENT) 
            {
                e->DecAt( aL); 
                res = NULL;
                break;
            }
            if( dec_inc == INCSTATEMENT)
            {
                e->IncAt( aL);
                res = NULL;
                break;
            }

            if( dec_inc == DEC) e->DecAt( aL); 
            else if( dec_inc == INC) e->IncAt( aL);
//
            res=e->Index( aL);

            if( dec_inc == POSTDEC) e->DecAt( aL);
            else if( dec_inc == POSTINC) e->IncAt( aL);
        }
    | e=l_decinc_indexable_expr[ dec_inc]
        {
            if( dec_inc == DECSTATEMENT) 
            {
                e->Dec(); 
                res = NULL;
                break;
            }
            if( dec_inc == INCSTATEMENT)
            {
                e->Inc();
                res = NULL;
                break;
            }

            if( dec_inc == DEC) e->Dec();
            else if( dec_inc == INC) e->Inc();
  //          
            res = e->Dup();
            
            if( dec_inc == POSTDEC) e->Dec();
            else if( dec_inc == POSTINC) e->Inc();
        }
    ;

// struct assignment
// MAIN function: called from l_decinc_expr
l_decinc_dot_expr [int dec_inc] returns [BaseGDL* res]
    : #(dot:DOT 
            { 
                SizeT nDot=dot->nDot;
                auto_ptr<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
            } 
            l_dot_array_expr[ aD.get()] 
            (tag_array_expr[ aD.get()] /* nDot times*/ )+ 
        )         
        {
            if( dec_inc == DECSTATEMENT) 
            {
                aD->Dec(); 
                res = NULL;
            }
            else if( dec_inc == INCSTATEMENT)
            {
                aD->Inc();
                res = NULL;
            }
            else
            {
                if( dec_inc == DEC) aD->Dec(); //*** aD->Assign( dec_inc);
                else if( dec_inc == INC) aD->Inc();
//                
                res=aD->Resolve();
                
                if( dec_inc == POSTDEC) aD->Dec();
                else if( dec_inc == POSTINC) aD->Inc();
            }
        }
    ;

// l_decinc_expr is only used in dec/inc statements and within itself
l_decinc_expr [int dec_inc] returns [BaseGDL* res]
{
    BaseGDL*       e1;
}
    : #(QUESTION e1=expr
            { 
                auto_ptr<BaseGDL> e1_guard(e1);

                if( e1->True())
                {
                    res=l_decinc_expr(_t, dec_inc);
                }
                else
                {
                    _t=_t->GetNextSibling(); // jump over 1st expression
                    res=l_decinc_expr(_t, dec_inc);
                }
            }
        ) // trinary operator
    | #(ASSIGN 
            { 
                auto_ptr<BaseGDL> r_guard;
            } 
            ( e1=tmp_expr
                {
                    r_guard.reset( e1);
                }
            | e1=check_expr
                {
                    if( !callStack.back()->Contains( e1)) 
                        r_guard.reset( e1);
                }
            )
            { 
                RefDNode l = _t;

                BaseGDL** tmp;
            } 
            tmp=l_expr[ e1] // assign
            {
                _t = l;
            }
            res=l_decinc_expr[ dec_inc]
        )
    | res=l_decinc_array_expr[ dec_inc]
    | res=l_decinc_dot_expr[ dec_inc]
    | e1=r_expr
        {
            delete e1;
            throw GDLException( _t, 
                "Expression not allowed with decrement/increment operator.");
        }
    ;

// l expressions for assignment *************************
// called from l_array_expr
l_indexoverwriteable_expr returns [BaseGDL** res]
//     : #(EXPR res=l_expr[ NULL])
//     | res=l_function_call
    : res=l_function_call
    | res=l_deref
    | res=l_simple_var
    ;

// an indexable expression must be defined
l_indexable_expr returns [BaseGDL** res]
    : #(EXPR res=l_expr[ NULL]) // for l_dot_array_expr
        {
            if( *res == NULL)
            throw GDLException( _t, "Variable is undefined: "+Name(res));
        }
    | res=l_function_call
        {
            if( *res == NULL)
            throw GDLException( _t, "Variable is undefined: "+Name(res));
        }
    | res=l_deref
        {
            if( *res == NULL)
            throw GDLException( _t, "Variable is undefined: "+Name(res));
        }
    | res=l_defined_simple_var                         
    | res=l_sys_var 
    ;

// called from l_expr
l_array_expr [BaseGDL* right] returns [BaseGDL** res]
{
    ArrayIndexListT* aL;
    auto_ptr<ArrayIndexListT> guard;
}
    : #(ARRAYEXPR aL=arrayindex_list { guard.reset(aL);} res=l_indexable_expr)   
        {
            if( right == NULL)
            throw GDLException( _t, 
                "Indexed expression not allowed in this context.");

            aL->SetVariable( *res);
            
            if( (*res)->EqType( right))
            {
                (*res)->AssignAt( right, aL); // assigns inplace
            }
            else
            {
                BaseGDL* rConv = right->Convert2( (*res)->Type(), BaseGDL::COPY);
                auto_ptr<BaseGDL> conv_guard( rConv);
                
                (*res)->AssignAt( rConv, aL); // assigns inplace
            }
        }
    | res=l_indexoverwriteable_expr 
        {
            if( right != NULL && right != (*res))
            {
                // only here non-inplace copy is done
                delete *res;
                *res = right->Dup();
            }
        }
    | { RefDNode sysVar = _t;} // for error reporting
        res=l_sys_var // sysvars cannot change their type
        {
            if( right == NULL)
            throw GDLException( _t, 
                "System variable not allowed in this context.");
            
            BaseGDL* rConv = right->Convert2( (*res)->Type(), BaseGDL::COPY);
            auto_ptr<BaseGDL> conv_guard( rConv);
                
            if( right->N_Elements() != 1 && 
                ((*res)->N_Elements() != right->N_Elements()))
            {
                throw GDLException( _t, "Conflicting data structures: <"+
                    right->TypeStr()+" "+right->Dim().ToString()+">,!"+ 
                    sysVar->getText());
            }
            
            (*res)->AssignAt( rConv); // linear copy
        }
    ;

l_dot_array_expr [DotAccessDescT* aD] // 1st
{
    ArrayIndexListT* aL;
    BaseGDL**        rP;
    DStructGDL*      structR;
    auto_ptr<ArrayIndexListT> guard;
    bool isObj = callStack.back()->IsObject();
}
    : #(ARRAYEXPR aL=arrayindex_list { guard.reset(aL);} rP=l_indexable_expr)   
        {
            // check here for object and get struct
            structR=dynamic_cast<DStructGDL*>(*rP);
            if( structR == NULL)
            {
                if( isObj)
                {
                    DStructGDL* oStruct = ObjectStructCheckAccess( *rP, _t);

                    // oStruct cannot be "Assoc_"
                    aD->Root( oStruct, guard.release()); 
                }
                else
                {
                    throw GDLException( _t, "Expression must be a"
                        " STRUCT in this context: "+Name(*rP));
                }
            }
            else 
            {
                if( (*rP)->IsAssoc())
                throw GDLException( _t, "File expression not allowed "
                    "in this context: "+Name(*rP));
                
                aD->Root( structR, guard.release()); 
            }
        }
    | rP=l_indexable_expr
        {
            // check here for object and get struct
            structR = dynamic_cast<DStructGDL*>(*rP);
            if( structR == NULL)
            {
                if( isObj) // member access to object?
                {
                    DStructGDL* oStruct = ObjectStructCheckAccess( *rP, _t);

                    // oStruct cannot be "Assoc_"
                    aD->Root( oStruct); 
                }
                else
                {
                    throw GDLException( _t, "Expression must be a"
                        " STRUCT in this context: "+Name(*rP));
                }
            }
            else
            {
                if( (*rP)->IsAssoc())
                {
                    throw GDLException( _t, "File expression not allowed "
                        "in this context: "+Name(*rP));
                }
                
                aD->Root(structR); 
            }
        }
    ;

// struct assignment
// MAIN function: called from l_expr
l_dot_expr [BaseGDL* right] returns [BaseGDL** res]
    : #(dot:DOT 
            { 
                SizeT nDot=dot->nDot;
                auto_ptr<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
            } 
            l_dot_array_expr[ aD.get()] 
            (tag_array_expr[ aD.get()] /* nDot times*/ )+ 
        )         
        {
            if( right == NULL)
            throw GDLException( _t, "Struct expression not allowed in this context.");
            
            aD->Assign( right);

            res=NULL;
        }
    ;

// l_expr is only used in assignment and within itself
l_expr [BaseGDL* right] returns [BaseGDL** res]
{
    BaseGDL*       e1;
}
    : #(QUESTION e1=expr
            { 
                auto_ptr<BaseGDL> e1_guard(e1);

                if( e1->True())
                {
                    res=l_expr(_t, right);
                }
                else
                {
                    _t=_t->GetNextSibling(); // jump over 1st expression
                    res=l_expr(_t, right);
                }
            }
        ) // trinary operator
    | #(ASSIGN e1=expr
            { 
                auto_ptr<BaseGDL> r_guard;
            } 
            ( e1=tmp_expr
                {
                    r_guard.reset( e1);
                }
            | e1=check_expr
                {
                    if( !callStack.back()->Contains( e1)) 
                        r_guard.reset( e1);
                }
            )
            res=l_expr[ e1]
//             {
//                 if( (*res) == e1 || callStack.back()->Contains( e1)) 
//                     r_guard.release();
//             }
        )
    | res=l_array_expr[ right]
    | res=l_dot_expr[ right]
//    | { right == NULL}? res=l_function_call
    | e1=r_expr
        {
            delete e1;
            throw GDLException( _t, 
                "Expression not allowed as l-value.");
        }
    ;

// used in l_expr but also in parameter_def
l_simple_var returns [BaseGDL** res]
    : var:VAR // DNode.varIx is index into functions/procedures environment
        {
            res=&callStack.back()->GetKW(var->varIx); 
        }
    | varPtr:VARPTR // DNode.var   is ptr to common block variable
        {
            res=&varPtr->var->Data(); // returns BaseGDL* of var (DVar*) 
        }
    ;

l_defined_simple_var returns [BaseGDL** res]
    : var:VAR // DNode.varIx is index into functions/procedures environment
        {
            res=&callStack.back()->GetKW(var->varIx); 
            if( *res == NULL)
            throw GDLException( _t, "Variable is undefined: "+
                callStack.back()->GetString(var->varIx));
        }
    | varPtr:VARPTR // DNode.var   is ptr to common block variable
        {
            res=&varPtr->var->Data(); // returns BaseGDL* of var (DVar*) 
            if( *res == NULL)
            throw GDLException( _t, "Variable is undefined: "+
                callStack.back()->GetString( *res));
        }
    ;

l_sys_var returns [BaseGDL** res]
    : sysVar:SYSVAR  
        // RefDNode->getText() returns name which 
        // has to be searched 
        // in 'sysVarList' (objects.cpp) if RefDNode->var is NULL
        {
            if( sysVar->var == NULL) 
            {
                sysVar->var=FindInVarList(sysVarList,sysVar->getText());
                if( sysVar->var == NULL)		    
                throw GDLException( _t, "Not a legal system variable: !"+
                    sysVar->getText());

                // note: this works, because system variables are never 
                //       passed by reference
                SizeT rdOnlySize = sysVarRdOnlyList.size();
                for( SizeT i=0; i<rdOnlySize; ++i)
                  if( sysVarRdOnlyList[ i] == sysVar->var)
                    throw GDLException( _t, 
                    "Attempt to write to a readonly variable: !"+
                    sysVar->getText());
            }
            // system variables are always defined
            res=&sysVar->var->Data();
        }
    ;

// right expressions **********************************************************
// expressions which always only return a value
// expecting to delete any sub-expressions
r_expr returns [BaseGDL* res]
{
    BaseGDL* e1;
    BaseGDL* e2;
}
    :	#(NOT_OP e1=expr { res= e1->NotOp();} )
    |	#(UMINUS e1=expr { res= e1->UMinus();} )
    |	#(AND_OP e1=expr e2=expr)			// binary operators...
        {
            AdjustTypes(e1,e2);
            if( e1->Scalar())
            res= e2->AndOp(e1); // scalar+scalar or array+scalar
            else
            if( e2->Scalar())
            res= e1->AndOpInv(e2); // array+scalar
            else
            if( e1->N_Elements() <= e2->N_Elements())
            res= e1->AndOpInv(e2); // smaller_array + larger_array or same size
            else
            res= e2->AndOp(e1); // smaller + larger
        }
    |	#(OR_OP  e1=expr e2=expr)
        {
            AdjustTypes(e1,e2);
            if( e1->Scalar())
            res= e2->OrOp(e1); // scalar+scalar or array+scalar
            else
            if( e2->Scalar())
            res= e1->OrOpInv(e2); // array+scalar
            else
            if( e1->N_Elements() <= e2->N_Elements())
            res= e1->OrOpInv(e2); // smaller_array + larger_array or same size
            else
            res= e2->OrOp(e1); // smaller + larger
        }
    |	#(XOR_OP e1=expr e2=expr) // xor is only defined for integers
        {
            AdjustTypes(e1,e2);
            if( e1->N_Elements() <= e2->N_Elements())
            res= e1->XorOp(e2); // smaller_array + larger_array or same size
            else
            res= e2->XorOp(e1); // smaller + larger
        }
    |	#(EQ_OP e1=expr e2=expr)
        {
            AdjustTypes(e1,e2);
            res=e1->EqOp(e2);
        }
    |	#(NE_OP e1=expr e2=expr)
        {
            AdjustTypes(e1,e2);
            res=e1->NeOp(e2);
        }
    |	#(LE_OP e1=expr e2=expr)
        {
            AdjustTypes(e1,e2);
            res=e1->LeOp(e2);
        }
    |	#(LT_OP e1=expr e2=expr)
        {
            AdjustTypes(e1,e2);
            res=e1->LtOp(e2);
        }
    |	#(GE_OP e1=expr e2=expr)
        {
            AdjustTypes(e1,e2);
            res=e1->GeOp(e2);
        }
    |	#(GT_OP e1=expr e2=expr)
        {
            AdjustTypes(e1,e2);
            res=e1->GtOp(e2);
        }
    |	#(PLUS  e1=expr e2=expr)
        {
            AdjustTypes(e1,e2);
            if( e1->Scalar())
            res= e2->AddInv(e1); // scalar+scalar or array+scalar
            else
            if( e2->Scalar())
            res= e1->Add(e2); // array+scalar
            else
            if( e1->N_Elements() <= e2->N_Elements())
            res= e1->Add(e2); // smaller_array + larger_array or same size
            else
            res= e2->AddInv(e1); // smaller + larger
        }
    |	#(MINUS e1=expr e2=expr)
        {
            AdjustTypes(e1,e2);
            if( e1->Scalar())
            res= e2->SubInv(e1); // scalar+scalar or array+scalar
            else
            if( e2->Scalar())
            res= e1->Sub(e2); // array+scalar
            else
            if( e1->N_Elements() <= e2->N_Elements())
            res= e1->Sub(e2); // smaller_array + larger_array or same size
            else
            res= e2->SubInv(e1); // smaller + larger
        }
    |	#(LTMARK e1=expr e2=expr)
        {
            AdjustTypes(e1,e2);
            if( e1->Scalar())
            res= e2->LtMark(e1); // scalar+scalar or array+scalar
            else
            if( e2->Scalar())
            res= e1->LtMark(e2); // array+scalar
            else
            if( e1->N_Elements() <= e2->N_Elements())
            res= e1->LtMark(e2); // smaller_array + larger_array or same size
            else
            res= e2->LtMark(e1); // smaller + larger
        }
    |	#(GTMARK e1=expr e2=expr)
        {
            AdjustTypes(e1,e2);
            if( e1->Scalar())
            res= e2->GtMark(e1); // scalar+scalar or array+scalar
            else
            if( e2->Scalar())
            res= e1->GtMark(e2); // array+scalar
            else
            if( e1->N_Elements() <= e2->N_Elements())
            res= e1->GtMark(e2); // smaller_array + larger_array or same size
            else
            res= e2->GtMark(e1); // smaller + larger
        }
    |	#(ASTERIX e1=expr e2=expr)
        {
            AdjustTypes(e1,e2);
            if( e1->Scalar())
            res= e2->Mult(e1); // scalar+scalar or array+scalar
            else
            if( e2->Scalar())
            res= e1->Mult(e2); // array+scalar
            else
            if( e1->N_Elements() <= e2->N_Elements())
            res= e1->Mult(e2); // smaller_array + larger_array or same size
            else
            res= e2->Mult(e1); // smaller + larger
        }
    |	#(MATRIX_OP1 e1=expr e2=expr) // #
        {
            DType aTy=e1->Type();
            DType bTy=e2->Type();
            DType maxTy=(DTypeOrder[aTy] >= DTypeOrder[bTy])? aTy: bTy;

            DType cTy=maxTy;
            if( maxTy == BYTE || maxTy == INT)
            cTy=LONG;
            else if( maxTy == UINT)
            cTy=ULONG;

            if( aTy != cTy) e1=e1->Convert2( cTy);

            AdjustTypes(e1,e2);
            res=e1->MatrixOp(e2);
        }
    |	#(MATRIX_OP2 e1=expr e2=expr) // ##
        {
            DType aTy=e1->Type();
            DType bTy=e2->Type();
            DType maxTy=(DTypeOrder[aTy] >= DTypeOrder[bTy])? aTy: bTy;

            DType cTy=maxTy;
            if( maxTy == BYTE || maxTy == INT)
            cTy=LONG;
            else if( maxTy == UINT)
            cTy=ULONG;

            if( aTy != cTy) e1=e1->Convert2( cTy);

            AdjustTypes(e1,e2);
            res=e2->MatrixOp(e1);
        }
    |	#(SLASH e1=expr e2=expr)
        {
            AdjustTypes(e1,e2);
            if( e1->Scalar())
            res= e2->DivInv(e1); // scalar+scalar or array+scalar
            else
            if( e2->Scalar())
            res= e1->Div(e2); // array+scalar
            else
            if( e1->N_Elements() <= e2->N_Elements())
            res= e1->Div(e2); // smaller_array + larger_array or same size
            else
            res= e2->DivInv(e1); // smaller + larger
        }
    |	#(MOD_OP e1=expr e2=expr)
        {
            AdjustTypes(e1,e2);
            if( e1->Scalar())
            res= e2->ModInv(e1); // scalar+scalar or array+scalar
            else
            if( e2->Scalar())
            res= e1->Mod(e2); // array+scalar
            else
            if( e1->N_Elements() <= e2->N_Elements())
            res= e1->Mod(e2); // smaller_array + larger_array or same size
            else
            res= e2->ModInv(e1); // smaller + larger
        }
    |	#(POW e1=expr e2=expr)
        {
            AdjustTypes(e1,e2);
            if( e1->Scalar())
            res= e2->PowInv(e1); // scalar+scalar or array+scalar
            else
            if( e2->Scalar())
            res= e1->Pow(e2); // array+scalar
            else
            if( e1->N_Elements() <= e2->N_Elements())
            res= e1->Pow(e2); // smaller_array + larger_array or same size
            else
            res= e2->PowInv(e1); // smaller + larger
        }
    |	#(DEC res=l_decinc_expr[ DEC])
    |	#(INC res=l_decinc_expr[ INC])
    |	#(POSTDEC res=l_decinc_expr[ POSTDEC])
    |	#(POSTINC res=l_decinc_expr[ POSTINC])
    // logical expressions
    |   #(LOG_AND e1=expr e2=expr)
        {
            if( !e1->LogTrue()) {res = new DByteGDL( 0); break;}
            if( !e2->LogTrue()) {res = new DByteGDL( 0); break;}
            res = new DByteGDL( 1);
        }
    |   #(LOG_OR e1=expr e2=expr)
        {
            if( !e1->LogTrue()) {res = new DByteGDL( 1); break;}
            if( !e2->LogTrue()) {res = new DByteGDL( 1); break;}
            res = new DByteGDL( 0);
        }
    |   #(LOG_NEG e1=expr)
        {
            res = e1->LogNeg();
        }
    | res=constant                  
    | res=array_def
    | res=struct_def
    ;

// indexable_expr returns [BaseGDL* res]
// //     : #(EXPR res=expr)                       
// //     | res=simple_var                         
//     : res=simple_var                         
//     | res=sys_var 
//     ;

array_expr returns [BaseGDL* res]
{
    ArrayIndexListT* aL;
    BaseGDL* r;
    auto_ptr<BaseGDL> r_guard;
}
    : #(ARRAYEXPR aL=arrayindex_list 
            {
                auto_ptr<ArrayIndexListT> aL_guard(aL);
            }
            ( r=indexable_expr
            | r=indexable_tmp_expr { r_guard.reset( r);}
            | r=check_expr
                {
                    if( !callStack.back()->Contains( res)) 
                        r_guard.reset( r); // guard if no global data
                }
            )
            {
                res=r->Index( aL);
            }
        )   
//     | res=expr //indexable_expr
    ;

// for l and r expr
tag_expr [DotAccessDescT* aD] // 2nd...
{
    BaseGDL* e;
}
    : #(EXPR e=expr
            {
                auto_ptr<BaseGDL> e_guard(e);
                
                SizeT tagIx;
                int ret=e->Scalar2index(tagIx);
                if( ret < 1)
                throw GDLException( _t, "Expression must be a scalar"
                    " >= 0 in this context: "+Name(e));
                
                aD->Add( tagIx);
            }
        )                       
    | i:IDENTIFIER
        {
            std::string tagName=i->getText();
            aD->Add( tagName);
        }
    ;

// for l and r expr
tag_array_expr  [DotAccessDescT* aD] // 2nd...
{
    ArrayIndexListT* aL;
}
	: #(ARRAYEXPR aL=arrayindex_list { aD->AddIx(aL);} tag_expr[ aD])
    | { aD->AddIx(NULL);} tag_expr[ aD]
    ;

r_dot_indexable_expr [DotAccessDescT* aD] returns [BaseGDL* res] // 1st
{
    BaseGDL** e;
}
    : #(EXPR res=expr { aD->SetOwner( true);}) // ({tag:0}).tag should work 
    | e=l_defined_simple_var { res = *e;}
    |   // we cant use l_sys_var here because of copy protection
        // could use sysvar and SetOwner( true), but this is quicker
        res=sys_var_nocopy // system variables are always defined    
    ;

r_dot_array_expr [DotAccessDescT* aD] // 1st
{
    ArrayIndexListT* aL;
    BaseGDL*         r;
    DStructGDL*      structR;
    auto_ptr<ArrayIndexListT> guard;
    bool isObj = callStack.back()->IsObject();
}
// NOTE: r is owned by aD or a l_... (r must not be deleted here)
    : #(ARRAYEXPR aL=arrayindex_list { guard.reset(aL);} r=r_dot_indexable_expr[ aD])   
        {
            // check here for object and get struct
            structR=dynamic_cast<DStructGDL*>(r);
            if( structR == NULL)
            {
                if( isObj)
                {
                    DStructGDL* oStruct = ObjectStructCheckAccess( r, _t);
                    
//                    DStructGDL* obj = oStruct->Index( aL);

                    if( aD->IsOwner()) delete r; 
                    aD->SetOwner( false); // object struct, not owned
                    
                    aD->Root( oStruct, guard.release()); 
//                    aD->Root( obj); 

//                     BaseGDL* obj = r->Index( aL);
//                     auto_ptr<BaseGDL> objGuard( obj); // new object -> guard
                    
//                     DStructGDL* oStruct = ObjectStructCheckAccess( obj, _t);

//                     // oStruct cannot be "Assoc_"
//                     if( aD->IsOwner()) delete r; 
//                     aD->SetOwner( false); // object structs are never owned
//                     aD->Root( oStruct); 
                }
                else
                {
                    throw GDLException( _t, "Expression must be a"
                        " STRUCT in this context: "+Name(r));
                }
            }
            else
            {
                if( r->IsAssoc())
                throw GDLException( _t, "File expression not allowed "
                    "in this context: "+Name(r));
                
                aD->Root( structR, guard.release()); 
            }
        }
    | r=r_dot_indexable_expr[ aD]
        {
            // check here for object and get struct
            structR = dynamic_cast<DStructGDL*>(r);
            if( structR == NULL)
            {
                if( isObj) // memeber access to object?
                {
                    DStructGDL* oStruct = ObjectStructCheckAccess( r, _t);

                    // oStruct cannot be "Assoc_"
                    if( aD->IsOwner()) delete r;
                    aD->SetOwner( false); // object structs are never owned
                    aD->Root( oStruct); 
                }
                else
                {
                    throw GDLException( _t, "Expression must be a"
                        " STRUCT in this context: "+Name(r));
                }
            }
            else
            {
                if( r->IsAssoc())
                {
                    throw GDLException( _t, "File expression not allowed "
                        "in this context: "+Name(r));
                }
                
                aD->Root(structR); 
            }
        }
    ;

// Entry function for struct access
//#(DOT array_expr (tag_array_expr)+)                     
dot_expr returns [BaseGDL* res]
    : #(dot:DOT 
            { 
                SizeT nDot=dot->nDot;
                auto_ptr<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
            } 
            r_dot_array_expr[ aD.get()] 
            (tag_array_expr[ aD.get()] /* nDot times*/ )+ 
        )         
        { res= aD->Resolve();}
    ;

// indexable expressions are used to minimize copying of data
// ( via Dup())
// owned by caller
indexable_tmp_expr returns [BaseGDL* res]
{
    BaseGDL*  e1;
    BaseGDL** e2;
}
	: #(QUESTION e1=expr
            { 
                auto_ptr<BaseGDL> e1_guard(e1);

                if( e1->True())
                {   
                    res=expr(_t);
                }
                else
                {
                    _t=_t->GetNextSibling(); // jump over 1st expression
                    res=expr(_t);
                }
            }
        ) // trinary operator
        // note: still potentially very slow as copying of
        // data is done in any case
    | res=array_expr
    | res=dot_expr
    | res=assign_expr
    | res=function_call
    | res=r_expr
    ;
// not owned by caller 
indexable_expr returns [BaseGDL* res]
{
    BaseGDL** e2;
}
    : e2=l_defined_simple_var
        {
            res = *e2;
        }
    | res=sys_var_nocopy
    | e2=l_deref 
        { 
            if( *e2 == NULL)
            throw GDLException( _t, "Variable is undefined: "+Name(e2));
            res = *e2;
        }
    ;

// l_expr used as r_expr and true r_expr
expr returns [BaseGDL* res]
    : res=tmp_expr
    | res=check_expr
        {
            if( callStack.back()->Contains( res)) 
                res = res->Dup();
        }
    ;

check_expr returns [BaseGDL* res]
    : res=lib_function_call 
    ;

// l_expr used as r_expr and true r_expr
tmp_expr returns [BaseGDL* res]
{
    BaseGDL*  e1;
    BaseGDL** e2;
}
    : e2=l_deref 
        { 
            if( *e2 == NULL)
            throw GDLException( _t, "Variable is undefined: "+Name(e2));
            
            res = (*e2)->Dup();
        }
	| #(QUESTION e1=expr
            { 
                auto_ptr<BaseGDL> e1_guard(e1);

                if( e1->True())
                {
                    res=expr(_t);
                }
                else
                {
                    _t=_t->GetNextSibling(); // jump over 1st expression
                    res=expr(_t);
                }
            }
        ) // trinary operator
    | res=array_expr
    | res=dot_expr
    | res=assign_expr
    | res=function_call
    | res=r_expr
        // *********
    | res=simple_var                         
    | res=sys_var 
    ;

assign_expr returns [BaseGDL* res]
{
    BaseGDL** l;
}
    : #(ASSIGN 
            { 
                auto_ptr<BaseGDL> r_guard;
            } 
            ( res=tmp_expr
                {
                    r_guard.reset( res);
                }
            | res=check_expr
                {
                    if( !callStack.back()->Contains( res)) 
                        r_guard.reset( res);
                }
            )
            l=l_expr[ res]
            { 
                r_guard.release();
            } // here res is returned!
        )
    ;

simple_var returns [BaseGDL* res]
    : var:VAR // DNode.varIx is index into functions/procedures environment
        {
            BaseGDL* vData=callStack.back()->GetKW( var->varIx);
            
            if( vData == NULL)
            throw GDLException( _t, "Variable is undefined: "+var->getText());
            
            res=vData->Dup();
        }
    | varPtr:VARPTR // DNode.var   is ptr to common block variable
        {
            BaseGDL* vData=varPtr->var->Data();
            
            if( vData == NULL)
            throw GDLException( _t, "Common block variable is undefined.");
            
            res=vData->Dup();
        }
    ;

sys_var returns [BaseGDL* res]
{
    BaseGDL* sv;
}
    : sv=sys_var_nocopy 
        {
            res=sv->Dup();
        }
    ;

sys_var_nocopy returns [BaseGDL* res]
    : sysVar:SYSVAR 
        // RefDNode->getText() returns name which has to be searched 
        // in 'sysVarList' (objects.cpp) if RefDNode->var is NULL
        {
            if( sysVar->var == NULL) 
            {
                sysVar->var=FindInVarList(sysVarList,sysVar->getText());
                if( sysVar->var == NULL)		    
                throw GDLException( _t, "Not a legal system variable: "+
                                    sysVar->getText());
            }

            // system variables are always defined
            res=sysVar->var->Data(); // no ->Dup()
        }
    ;

constant returns [BaseGDL* res]
    : c:CONSTANT
        {
            res=c->cData->Dup(); 
        }
  ;

lib_function_call returns[ BaseGDL* res]
{ 
    // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
    StackGuard<EnvStackT> guard(callStack);
}
	: #(FCALL_LIB fl:IDENTIFIER
            {
                EnvT* newEnv=new EnvT( this, fl, libFunList[fl->funIx]);
            }
            parameter_def[ newEnv]
            {
                // push id.pro onto call stack
                callStack.push_back(newEnv);
                // make the call
                res=static_cast<DLibFun*>(newEnv->GetPro())->Fun()(newEnv);
                //*** MUST always return a defined expression
            }
        )
    ;    


function_call returns[ BaseGDL* res]
{ 
    // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
    StackGuard<EnvStackT> guard(callStack);
    BaseGDL *self;
    EnvT*   newEnv;
}
    :    (
        ( #(MFCALL 
                self=expr mp:IDENTIFIER
                {  
                    auto_ptr<BaseGDL> self_guard(self);
                    
                    newEnv=new EnvT( this, self, mp);

                    self_guard.release();
                }
                parameter_def[ newEnv]
            )
        | #(MFCALL_PARENT 
                self=expr parent:IDENTIFIER p:IDENTIFIER
                {
                    auto_ptr<BaseGDL> self_guard(self);
                    
                    newEnv=new EnvT( this, self, p,
                        parent->getText());

                    self_guard.release();
                }
                parameter_def[ newEnv]
            )
        | #(FCALL f:IDENTIFIER
                {
                    SetFunIx( f);
                    
                    newEnv=new EnvT( this, f, funList[f->funIx]);
                }
                parameter_def[ newEnv]
            )
        )
        {
            // push environment onto call stack
            callStack.push_back(newEnv);
            
            // make the call
            res=call_fun(static_cast<DSubUD*>(newEnv->GetPro())->GetTree());
        } 
        )
	;	

// function call can be l_values (within (#EXPR ...) only)
l_function_call returns[ BaseGDL** res]
{ 
    // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
    StackGuard<EnvStackT> guard(callStack);
    BaseGDL *self;
    BaseGDL *libRes;
    EnvT*   newEnv;
}

	: #(FCALL_LIB fl:IDENTIFIER
            {
                EnvT* newEnv=new EnvT( this, fl, libFunList[fl->funIx]);
            }
            parameter_def[ newEnv]
            {
                EnvT* callerEnv = callStack.back();
                // push id.pro onto call stack
                callStack.push_back(newEnv);
                // make the call
                BaseGDL* libRes = 
                static_cast<DLibFun*>(newEnv->GetPro())->Fun()(newEnv);
                
                res = callerEnv->GetPtrTo( libRes);
                if( res == NULL)
                throw GDLException( _t, "Library function must return a "
                    "l-value in this context: "+fl->getText());
            }
        )
    |
        (
        ( #(MFCALL 
                self=expr mp:IDENTIFIER
                {  
                    auto_ptr<BaseGDL> self_guard(self);
                    
                    newEnv=new EnvT( this, self, mp, "", true);

                    self_guard.release();
                }
                parameter_def[ newEnv]
            )
        | #(MFCALL_PARENT 
                self=expr parent:IDENTIFIER p:IDENTIFIER
                {
                    auto_ptr<BaseGDL> self_guard(self);
                    
                    newEnv=new EnvT( this, self, p,
                        parent->getText(), true);

                    self_guard.release();
                }
                parameter_def[ newEnv]
            )

        | #(FCALL f:IDENTIFIER
                {
                    SetFunIx( f);
                    
                    newEnv=new EnvT( this, f, funList[f->funIx], true);
                }
                parameter_def[ newEnv]
            )
        )
        {
            // push environment onto call stack
            callStack.push_back(newEnv);
            
            // make the call
            res=call_lfun(static_cast<DSubUD*>(
                    newEnv->GetPro())->GetTree());
        }   
        )
	;	

ref_parameter returns[ BaseGDL** ret]
    : ret=l_simple_var
    | ret=l_deref
    ;

// the environment must be on the callstack
parameter_def [EnvT* actEnv] 
{
    auto_ptr<EnvT> guard(actEnv); 
    BaseGDL*  kval;
    BaseGDL*  pval;
    BaseGDL** kvalRef;
    BaseGDL** pvalRef;
}
    : (  #(KEYDEF_REF knameR:IDENTIFIER kvalRef=ref_parameter
                {   // pass reference
                    actEnv->SetKeyword( knameR->getText(), kvalRef); 
                }
            )
        | #(KEYDEF_REF_EXPR knameE:IDENTIFIER 
                // execute ++ and assignment
                kval=expr 
                kvalRef=ref_parameter
                {   // pass reference
                    delete kval;
                    actEnv->SetKeyword( knameE->getText(), kvalRef); 
                }
            )
        | #(KEYDEF kname:IDENTIFIER kval=expr
                {   // pass value
                    actEnv->SetKeyword( kname->getText(), kval);
                }
            )
        | #(REF pvalRef=ref_parameter
                {   // pass reference
                    actEnv->SetNextPar(pvalRef); 
                }   
            )
        | #(REF_EXPR 
                // execute ++ and assignment
                pval=expr 
                pvalRef=ref_parameter
                {   // pass reference
                    delete pval;
                    actEnv->SetNextPar(pvalRef); 
                }   
            )
        | pval=expr
            {   // pass value
                actEnv->SetNextPar(pval); 
            }
        | #(KEYDEF_REF_CHECK knameCk:IDENTIFIER 
                kval=check_expr
                {
                    kvalRef = callStack.back()->GetPtrTo( kval);
                    if( kvalRef != NULL)
                    {   // pass reference
                        actEnv->SetKeyword(knameCk->getText(), kvalRef); 
                    }
                    else 
                    {   // pass value
                        actEnv->SetKeyword(knameCk->getText(), kval); 
                    }
                }
            )   
        | #(REF_CHECK
                pval=check_expr
                {
                    pvalRef = callStack.back()->GetPtrTo( pval);
                    if( pvalRef != NULL)
                    {   // pass reference
                        actEnv->SetNextPar( pvalRef); 
                    }
                    else 
                    {   // pass value
                        actEnv->SetNextPar( pval); 
                    }
                }       
            )
        )*             
        {
            actEnv->Extra(); // expand _EXTRA
            guard.release();
        }
	;

arrayindex_all returns[ ArrayIndexT arrIx] // ALL [*]
    : ALL { arrIx = ArrayIndexT();}
    ;

arrayindex_range returns[ ArrayIndexT arrIx] // RANGE [s:e]
{
    BaseGDL* s;
    BaseGDL* e;
    SizeT sIx,eIx;
    int    retMsg=0;
}    
    : s=expr e=expr
        {
            auto_ptr<BaseGDL> s_guard(s);
            auto_ptr<BaseGDL> e_guard(e);

            retMsg=s->Scalar2index(sIx);
            if( retMsg == 0) // index empty or array
            {
                if( s->N_Elements() == 0)
                throw 
                GDLException( _t, "Internal error: Scalar2index: 1st index empty."); 
                else
                throw 
                GDLException( _t, "Expression must be a scalar in this context."); 
            }
            if( retMsg == -1) // index < 0
            {
                throw 
                GDLException( _t, "Subscript range values of the form low:high " 
                    "must be >= 0, < size, with low <= high.");
            }
            
            retMsg=e->Scalar2index(eIx);
            if( retMsg == 0) // index empty or array
            {
                if( e->N_Elements() == 0)
                throw 
                GDLException( _t, "Internal error: Scalar2index: 2nd index empty."); 
                else
                throw 
                GDLException( _t, "Expression must be a scalar in this context."); 
            }
            if( retMsg == -1) // index < 0
            {
                throw 
                GDLException( _t, "Subscript range values of the form low:high " 
                    "must be >= 0, < size, with low <= high.");
            }
            
            if( eIx < sIx)
            {
                throw 
                GDLException( _t, " Subscript range values of the form low:high " 
                    "must be >= 0, < size, with low <= high");
            }
                            
            arrIx = ArrayIndexT(ArrayIndexT::RANGE,sIx,eIx);
            }
    ;

arrayindex_end returns[ ArrayIndexT arrIx] // ORANGE [s:*]
{
    BaseGDL* s;
    SizeT sIx;
    int    retMsg=0;
}    
    : s=expr
        {
            auto_ptr<BaseGDL> s_guard(s);

            retMsg=s->Scalar2index(sIx);
            if( retMsg == 0) // index empty or array
            {
                if( s->N_Elements() == 0)
                throw 
                GDLException( _t, "Internal error: Scalar2index:"
                    " 1st index empty"); 
                else
                throw 
                GDLException( _t, "Expression must be a scalar"
                    " in this context."); 
            }
            if( retMsg == -1) // index < 0
            {
                throw 
                GDLException( _t, "Subscript range values of the"
                    " form low:high must be >= 0, < size, with low <= high.");
            }
            arrIx = ArrayIndexT(ArrayIndexT::ORANGE,sIx);
        }
    ;

arrayindex returns[ ArrayIndexT arrIx] // type: 0 [data], 2 [s]
{
    BaseGDL* s;
    SizeT   sIx;
    int      retMsg=0;
}    
    : s=expr
        {
            auto_ptr<BaseGDL> s_guard(s);
            
            if( s->N_Elements() == 0) // index empty or array
            {
                throw 
                GDLException( _t, "Internal error: Scalar2index: 1st"
                    " index empty"); 
            }
            
            if( s->Rank() != 0)
            {
                // INDEXED
                s_guard.release();
                arrIx = 
                ArrayIndexT( static_cast< DLongGDL*>(s->Convert2( LONG))); 
            }
            else
            {
                retMsg=s->Scalar2index(sIx);
                if( retMsg == -1) // index < 0
                {
                    throw 
                    GDLException( _t, "Subscript range values of the"
                        " form low:high must be >= 0, < size,"
                        " with low <= high.");
                }
                else arrIx = ArrayIndexT(ArrayIndexT::ONE, sIx); // ONE
            }
        }
    ;

// note: [*:n], [*:*] already filtered out
// type: 0->data, 1-> [*], 2-> [s], 3-> [s:*], 4-> [s:e]
arrayindex_list returns [ArrayIndexListT* aL]
{
    // auto_ptr -> exception-save
    auto_ptr<ArrayIndexListT> arrList(new ArrayIndexListT());
    ArrayIndexT arrIx;
}
	: ( #(ARRAYIX // INDEXED or ONE
                arrIx=arrayindex
                { arrList->push_back(arrIx);}
            )
        |#(ARRAYIX_ALL // ALL 
                arrIx=arrayindex_all
                { arrList->push_back(arrIx);}
            )
        |#(ARRAYIX_ORANGE // ORANGE
                arrIx=arrayindex_end
                { arrList->push_back(arrIx);}
            )
        |#(ARRAYIX_RANGE // RANGE
                arrIx=arrayindex_range
                { arrList->push_back(arrIx);}
            )
      )+
        {
            // release
            aL=arrList.release();
        }
    ;

// and array_def is a primary expression
array_def returns [BaseGDL* res]
{
    DType  cType=UNDEF; // conversion type
    SizeT maxRank=0;
    BaseGDL* e;
    ExprListT          exprList;
    BaseGDL*           cTypeData;
}
    : #(a:ARRAYDEF 
            (e=expr
                {
                    // add first (this way it will get cleaned up anyway)
                    exprList.push_back(e);
                    
                    DType ty=e->Type();
                    if( ty == UNDEF)
                    {
                        throw GDLException( _t, "Variable is undefined: "+
                            Name(e));
                    }
                    if( cType == UNDEF) 
                    {
                        cType=ty;
                        cTypeData=e;
                    }
                    else 
                    { 
                        if( cType != ty) 
                        {
                            if( DTypeOrder[ty] > 100) // struct, ptr, object
                            {
                                throw 
                                GDLException( _t, e->TypeStr()+
                                    " is not allowed in this context.");
                            }
                            
                            // update order if larger type (or types are equal)
                            if( DTypeOrder[ty] >= DTypeOrder[cType]) 
                            {
                                cType=ty;
                                cTypeData=e;
                            }
                        }
                        if( ty == STRUCT)
                        {
                            // check for struct compatibility
                            DStructDesc* newS=
                            static_cast<DStructGDL*>(e)->Desc();
                            DStructDesc* oldS=
                            static_cast<DStructGDL*>(cTypeData)->Desc();

                            // *** here (*newS) != (*oldS) must be set when
                            // unnamed structs not in struct list anymore
                            // WRONG! This speeds up things for named structs
                            // unnamed structs all have their own desc
                            // and thus the next is always true for them
                            if( newS != oldS)
                            {
//                                 if( (*newS) == (*oldS))
//                                 {
// Not needed, CatArray puts the right descriptor
//                                     // different structs with same layout
//                                     // replace desc with first one
//                                     if( oldS->IsUnnamed())
//                                         oldS = new DStructDesc( oldS);

//                                     static_cast<DStructGDL*>(e)->SetDesc( oldS);
//                                 }
//                                 else

                                if( (*newS) != (*oldS))
                                    throw GDLException( _t, 
                                        "Conflicting data structures: "+
                                        Name(cTypeData)+", "+Name(e));
                            }
                        }
                    }

                    // memorize maximum Rank
                    SizeT rank=e->Rank();
                    if( rank > maxRank) maxRank=rank;
                }
            )+
        )
        {  
            res=cTypeData->CatArray(exprList,a->arrayDepth,maxRank);
        }
  ;


named_struct_def returns[ BaseGDL* res]
{
    DStructDesc*          nStructDesc;
    auto_ptr<DStructDesc> nStructDescGuard;
    BaseGDL* e;
    BaseGDL* ee;
}
	: #(n:NSTRUC id:IDENTIFIER 
            {
                if( n->definedStruct == 1) GetStruct( id->getText(), _t);

                // find struct 'id' (for compatibility check)
                DStructDesc* oStructDesc=
                FindInStructList( structList, id->getText());
                
                if( oStructDesc == NULL || oStructDesc->NTags() > 0)
                {
                    // not defined at all yet (-> define now)
                    // or completely defined  (-> define now and check equality)
                    nStructDesc= new DStructDesc( id->getText());
                    
                    // guard it
                    nStructDescGuard.reset( nStructDesc); 
                } 
                else
                {   // NTags() == 0
                    // not completely defined (only name in list)
                    nStructDesc= oStructDesc;
                }
                
                // the instance variable
                DStructGDL* instance= new DStructGDL( nStructDesc); 
                auto_ptr<DStructGDL> instance_guard(instance);
            }

            // PROBLEM: both the descriptor AND the instance must be defined
            ( ee=expr
                {
                    // also adds to descriptor, grabs
                    instance->NewTag( 
                        oStructDesc->TagName( nStructDesc->NTags()),
                        ee);
                }
            | i:IDENTIFIER e=expr // e is a new BaseGDL*
                {
                    // also adds to descriptor, grabs
                    instance->NewTag( i->getText(), e); 
                }
            | INHERITS ii:IDENTIFIER
            // INHERITS triggers read/compile/interpret of 
            // IDENTIFIER__define.pro
            // if the struct named IDENTIFIER is not already known
                {
                    DStructDesc* inherit=GetStruct( ii->getText(), _t);

                    nStructDesc->AddParent( inherit);
                    instance->AddParent( inherit);
                }
                
            )+
       
            {
                // inherit refers to nStructDesc, in case of error both have to
                // be freed here
                if( oStructDesc != NULL)
                {
                    if( oStructDesc != nStructDesc)
                    {
                        oStructDesc->AssureIdentical(nStructDesc);
                        instance->SetDesc(oStructDesc);
                        //delete nStructDesc; // auto_ptr
                    }
                }
                else
                {
                    // release from guard (if not NULL)
                    nStructDescGuard.release();

                    // insert into struct list 
                    structList.push_back(nStructDesc);
                }
                
                instance_guard.release();
                res=instance;
            }
        )
    ;

unnamed_struct_def returns[ BaseGDL* res]
{
    // don't forget the struct in extrat.cpp if you change something here
    // "$" as first char in the name is necessary 
    // as it defines unnnamed structs (see dstructdesc.hpp)
    DStructDesc*   nStructDesc = new DStructDesc( "$truct");

    // instance takes care of nStructDesc since it is unnamed
    DStructGDL* instance = new DStructGDL( nStructDesc);
    auto_ptr<DStructGDL> instance_guard(instance);

    BaseGDL* e;
}
	: #(STRUC 
            ( si:IDENTIFIER e=expr
                {
                    // also adds to descriptor, grabs
                    instance->NewTag( si->getText(), e); 
                }
            )+
            
            {
//                 DStructDesc* oStructDesc=nStructDesc->FindEqual( structList);
//                 if( oStructDesc != NULL)
//                 {
//                     instance->SetDesc(oStructDesc);
//                     //delete nStructDesc; // auto_ptr
//                 }
//                 else
//                 {
//                     // insert into struct list
//                     structList.push_back( nStructDesc.release());
//                 }
                
                instance_guard.release();
                res=instance;
            }
        )
    ;

// only from named structs
struct_def returns[ BaseGDL* res]
    : res=named_struct_def
    | res=unnamed_struct_def
	| #(NSTRUC_REF idRef:IDENTIFIER 
            {
                // find struct 'id'
                // returns it or throws an exception
                DStructDesc* dStruct=GetStruct( idRef->getText(), _t);
                
                res=new DStructGDL( dStruct);
            }
        )
	;
