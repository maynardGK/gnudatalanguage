/* *************************************************************************
                          gdlc.i.g 
the GDL interpreter
interprets the output of the treeparser/compiler
                             -------------------
    begin                : July 22 2002
    copyright            : (C) 2002 by Marc Schellens
    email                : m_schellens@hotmail.com
 ***************************************************************************/

/* *************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

header "pre_include_cpp" {
    // gets inserted before the antlr generated includes in the cpp file
#include "includefirst.hpp"
}

header "post_include_cpp" {
    // gets inserted after the antlr generated includes in the cpp file
#include "dinterpreter.hpp"
#include "prognodeexpr.hpp"

#include <cassert>

// tweaking ANTLR
#define ASTNULL          NULLProgNodeP
#define ProgNodeP( xxx ) NULL             /* ProgNodeP(antlr::nullAST) */
#define RefAST( xxx)     ConvertAST( xxx) /* antlr::RefAST( Ref type)  */
#define match( a, b)     /* remove from source */

// optimizations
// #define  constant constantNotOptimized
// #define  interactive interactiveNotOptimized
// #define  statement_list statement_listNotOptimized
// #define  execute executeNotOptimized
// #define  call_fun call_funNotOptimized
// #define  call_lfun call_lfunNotOptimized
// #define  call_pro call_proNotOptimized 
// #define  block blockNotOptimized
// #define  expr exprNotOptimized
// #define  l_simple_var l_simple_varNotOptimized
// #define  sys_var sys_varNotOptimized
// #define  sys_var_nocopy sys_var_nocopyNotOptimized
// #define  dot_expr dot_exprNotOptimized
// #define  simple_var simple_varNotOptimized
// #define  ref_parameter ref_parameterNotOptimized
// #define  unnamed_struct_def unnamed_struct_defNotOptimized
// #define  lib_function_call_retnew lib_function_call_retnewNotOptimized
// #define  lib_function_call lib_function_callNotOptimized
// #define  constant_nocopy constant_nocopyNotOptimized
// #define  struct_def struct_defNotOptimized


using namespace std;
}

header {
    // antlr header

    // make sure it gets included before the 'tweak'
#include "GDLParser.hpp" 
#include "GDLTreeParser.hpp" 

#include <map>
#include <iomanip>
//#include <exception>

#include "datatypes.hpp"
#include "objects.hpp"
#include "dpro.hpp"
#include "accessdesc.hpp"
#include "initsysvar.hpp"
#include "gdljournal.hpp"

//class ProgNode;
//typedef ProgNode* ProgNodeP;

// tweaking ANTLR
#define RefAST( xxx)     ConvertAST( xxx) /* antlr::RefAST( Ref type)  */

// print out AST tree
//#define GDL_DEBUG
//#undef GDL_DEBUG
//#define GDL_DEBUG_HEAP

}

options {
	language="Cpp";
	genHashLines = false;
	namespaceStd="std";         // cosmetic option to get rid of long defines
	namespaceAntlr="antlr";     // cosmetic option to get rid of long defines
}	

// the GDL TreeParser  ****************************************
class GDLInterpreter extends TreeParser;

options {
  importVocab = GDL;	// use vocab generated by lexer
  buildAST = false;     // no modifying of AST anymore
    // no AST is created in the interpreter, hence we don't need ref counting
//  ASTLabelType = "RefDNode"; 
  ASTLabelType = "ProgNodeP"; 
//  defaultErrorHandler = true;
  defaultErrorHandler = false;
//  codeGenMakeSwitchThreshold = 2;
//  codeGenBitsetTestThreshold = 32;
}

{
private:
    // ASTNULL replacement
    static ProgNode  NULLProgNode;
    static ProgNodeP NULLProgNodeP;

    friend class BaseGDL;
    friend class ProgNode;
    friend class ARRAYDEFNode;
    friend class STRUCNode;
    friend class NSTRUCNode;
    friend class NSTRUC_REFNode;
    friend class ASSIGNNode;
    friend class ASSIGN_ARRAYEXPR_MFCALLNode;
    friend class ASSIGN_REPLACENode;
friend class PCALL_LIBNode;//: public CommandNode
friend class MPCALLNode;//: public CommandNode
friend class MPCALL_PARENTNode;//: public CommandNode
friend class PCALLNode;//: public CommandNode

  friend class KEYDEFNode;
  friend class KEYDEF_REFNode;
  friend class KEYDEF_REF_CHECKNode;
  friend class KEYDEF_REF_EXPRNode;
  friend class REFNode;
  friend class REF_CHECKNode;
  friend class REF_EXPRNode;
  friend class ParameterNode;

public: 
//     RetCode returnCode;    

    void SetRetTree( ProgNodeP rT)
    {
        this->_retTree = rT;
    }
//     void SetReturnCode( RetCode rC)
//     {
//         this->returnCode = rC;
//     }
    
    enum RetCode {
        RC_OK=0,
        RC_BREAK,
        RC_CONTINUE,
        RC_RETURN, 
        RC_ABORT, // checked as retCode >= RC_RETURN
    };  

    // code in: dinterpreter.cpp
    static bool SearchCompilePro(const std::string& pro);
    static int GetFunIx( ProgNodeP);
    static int GetFunIx( const std::string& subName);
    static int GetProIx( ProgNodeP);//const std::string& subName);
    static int GetProIx( const std::string& subName);
    DStructGDL* ObjectStruct( BaseGDL* self, ProgNodeP mp);
    DStructGDL* ObjectStructCheckAccess( BaseGDL* self, ProgNodeP mp);

private: 
    // code in: dinterpreter.cpp
    static void SetFunIx( ProgNodeP f); // triggers read/compile
    static void SetProIx( ProgNodeP f); // triggers read/compile
    static void AdjustTypes( BaseGDL*&, BaseGDL*&);


protected:
    std::istringstream executeLine; // actual interactive executed line

//     std::vector<BaseGDL*> tmpList;
//     void ClearTmpList()
//     {
//         std::vector<BaseGDL*>::iterator i;
//         for(i = tmpList.begin(); i != tmpList.end(); ++i) 
//             { delete *i;}
//         tmpList.clear();
//     }

    class RetAllException 
    {
        public:
        enum ExCode {
            NONE=0, // normal RETALL
            RUN     // RETALL from .RUN command
        };  

        private:
        ExCode code;

        public:
        RetAllException( ExCode code_=NONE): code( code_) {}

        ExCode Code() { return code;}
    };
    
    // code in: dinterpreter.cpp
//    static bool CompleteFileName(std::string& fn); -> str.cpp
    static bool CompileFile(const std::string& f, const std::string& untilPro=""); 
    BaseGDL*  returnValue;  // holding the return value for functions
    BaseGDL** returnValueL; // holding the return value for l_functions

    bool interruptEnable;

    typedef RefHeap<BaseGDL> RefBaseGDL;
    typedef RefHeap<DStructGDL> RefDStructGDL;

    typedef std::map<SizeT, RefBaseGDL> HeapT;
    typedef std::map<SizeT, RefDStructGDL> ObjHeapT;
//     typedef std::map<SizeT, BaseGDL*> HeapT;
//     typedef std::map<SizeT, DStructGDL*> ObjHeapT;

    // the following must be all static because several interpreter might be active
    // the heap for all dynamic variables
    // ease the handling, no memory leaks, gc possible
    static HeapT     heap; 
    static ObjHeapT  objHeap; 

    // index for newly allocated heap variables
    static SizeT objHeapIx;
    static SizeT heapIx;

    static EnvStackT  callStack; 


// smuggle optimizations in
//#include "GDLInterpreterOptimized.inc"


public:
    // triggers read/compile/interpret
    DStructDesc* GetStruct(const std::string& name, const ProgNodeP cN); 

    // the New... functions 'own' their BaseGDL*
    SizeT NewObjHeap( SizeT n=1, DStructGDL* var=NULL)
    {
        SizeT tmpIx=objHeapIx;
        for( SizeT i=0; i<n; i++)
        objHeap.insert( objHeap.end(),
            std::pair<SizeT, RefDStructGDL>( objHeapIx++, (DStructGDL*)var));
        return tmpIx;
    }
    SizeT NewHeap( SizeT n=1, BaseGDL* var=NULL)
    {
        SizeT tmpIx=heapIx;
        for( SizeT i=0; i<n; i++)
        heap.insert( heap.end(),
            std::pair<SizeT, RefBaseGDL>( heapIx++, var));
        return tmpIx;
    }
    static void FreeObjHeap( DObj id)
    {
        if( id != 0)
        {       
            ObjHeapT::iterator it=objHeap.find( id);
            if  ( it != objHeap.end()) 
            { 
                delete (*it).second.get();
                objHeap.erase( id);
            }
        }
    }
    static void FreeObjHeapDirect( DObj id, ObjHeapT::iterator it)
    {
        delete (*it).second.get();
        objHeap.erase( id);
    }
    static void FreeHeap( DPtr id)
    {
        if( id != 0)
            {
                HeapT::iterator it=heap.find( id);
                if( it != heap.end()) 
                    { 
                        delete (*it).second.get();
                        heap.erase( id); 
                    }
            }
    }
    static void FreeHeapDirect( DPtr id, HeapT::iterator it)
    {
        delete (*it).second.get();
        heap.erase( id); 
    }

   static void FreeHeap( DPtrGDL* p)
    {
        SizeT nEl=p->N_Elements();
        for( SizeT ix=0; ix < nEl; ix++)
        {
            DPtr id= (*p)[ix];
            FreeHeap( id);
       }
    }

   static void DecRef( DPtr id)
    {
        if( id != 0)
            {
#ifdef GDL_DEBUG_HEAP
                std::cout << "-- <PtrHeapVar" << id << ">" << std::endl; 
#endif
                HeapT::iterator it=heap.find( id);
                if( it != heap.end()) 
                    { 
                        if( (*it).second.Dec())
                            {
                                std::cout << "Out of scope (garbage collected): <PtrHeapVar" << id << ">" << std::endl; 
                                FreeHeapDirect( id, it);
                            }
#ifdef GDL_DEBUG_HEAP
                        else
std::cout << "<PtrHeapVar" << id << "> = " << (*it).second.Count() << std::endl; 
#endif
                    }
            }
    }
   static void DecRef( DPtrGDL* p)
    {
        SizeT nEl=p->N_Elements();
        for( SizeT ix=0; ix < nEl; ix++)
        {
            DPtr id= (*p)[ix];
            DecRef( id);
       }
    }
   static void DecRefObj( DObj id)
    {
        if( id != 0)
            {
#ifdef GDL_DEBUG_HEAP
std::cout << "-- <ObjHeapVar" << id << ">" << std::endl; 
#endif
                ObjHeapT::iterator it=objHeap.find( id);
                if( it != objHeap.end()) 
                    { 
                       if( (*it).second.Dec())
                           {
                               std::cout << "Out of scope (garbage collected): <ObjHeapVar" << id << ">" << std::endl; 
                               FreeObjHeapDirect( id, it);
                           }
#ifdef GDL_DEBUG_HEAP
                        else
std::cout << "<ObjHeapVar" << id << "> = " << (*it).second.Count() << std::endl; 
#endif
                        
                     }
            }
    }
   static void DecRefObj( DObjGDL* p)
    {
        SizeT nEl=p->N_Elements();
        for( SizeT ix=0; ix < nEl; ix++)
        {
            DObj id= (*p)[ix];
            DecRefObj( id);
       }
    }
   static void IncRef( DPtr id)
    {
        if( id != 0)
            {
#ifdef GDL_DEBUG_HEAP
std::cout << "++ <PtrHeapVar" << id << ">" << std::endl; 
#endif
                HeapT::iterator it=heap.find( id);
                if( it != heap.end()) 
                    { 
                        (*it).second.Inc(); 
#ifdef GDL_DEBUG_HEAP
std::cout << "<PtrHeapVar" << id << "> = " << (*it).second.Count() << std::endl; 
#endif
                    }
            }
    }
   static void AddRef( DPtr id, SizeT add)
    {
        if( id != 0)
            {
#ifdef GDL_DEBUG_HEAP
std::cout << add << " + <PtrHeapVar" << id << ">" << std::endl; 
#endif
                HeapT::iterator it=heap.find( id);
                if( it != heap.end()) 
                    { 
                        (*it).second.Add(add); 
                    }
            }
    }
   static void IncRef( DPtrGDL* p)
    {
        SizeT nEl=p->N_Elements();
        for( SizeT ix=0; ix < nEl; ix++)
        {
            DPtr id= (*p)[ix];
            IncRef( id);
       }
    }
   static void IncRefObj( DObj id)
    {
        if( id != 0)
            {
#ifdef GDL_DEBUG_HEAP
std::cout << "++ <ObjHeapVar" << id << ">" << std::endl; 
#endif
                ObjHeapT::iterator it=objHeap.find( id);
                if( it != objHeap.end()) 
                    { 
                        (*it).second.Inc(); 
                    }
            }
    }
   static void AddRefObj( DObj id, SizeT add)
    {
        if( id != 0)
            {
#ifdef GDL_DEBUG_HEAP
std::cout << add << " + <ObjHeapVar" << id << ">" << std::endl; 
#endif
                ObjHeapT::iterator it=objHeap.find( id);
                if( it != objHeap.end()) 
                    { 
                        (*it).second.Add(add); 
                    }
            }
    }
   static void IncRefObj( DObjGDL* p)
    {
        SizeT nEl=p->N_Elements();
        for( SizeT ix=0; ix < nEl; ix++)
        {
            DObj id= (*p)[ix];
            IncRefObj( id);
       }
    }

    class HeapException {};

    static BaseGDL*& GetHeap( DPtr ID)
    {
        HeapT::iterator it=heap.find( ID);
        if( it == heap.end()) throw HeapException();
        return it->second.get();
    }
    static DStructGDL*& GetObjHeap( DObj ID)
    {
        ObjHeapT::iterator it=objHeap.find( ID);
        if( it == objHeap.end()) throw HeapException();
        return it->second.get();
    }

    static bool PtrValid( DPtr ID)
    {
        HeapT::iterator it=heap.find( ID);
        return  (it != heap.end());
    }

    static SizeT HeapSize()
    {
        return heap.size();
    }

    static DPtr FindInHeap( BaseGDL** p)
    {
        for( HeapT::iterator it=heap.begin(); it != heap.end(); ++it)
        {
            if( &it->second.get() == p)
                return it->first;
        }
        return 0;
    }
    static DPtrGDL* GetAllHeap()
    {
        SizeT nEl = heap.size();
        if( nEl == 0) return new DPtrGDL( 0);
        DPtrGDL* ret = new DPtrGDL( dimension( &nEl, 1), BaseGDL::NOZERO);
        SizeT i=0;
        for( HeapT::iterator it=heap.begin(); it != heap.end(); ++it)
        {
            IncRef( it->first);
            (*ret)[ i++] = it->first;
        }
        return ret;
    }

    // no ref counting here
    static std::vector<DPtr>* GetAllHeapSTL()
    {
        SizeT nEl = heap.size();
        if( nEl == 0) return new std::vector<DPtr>();
        std::vector<DPtr>* ret = new std::vector<DPtr>( nEl);
        SizeT i=0;
        for( HeapT::iterator it=heap.begin(); it != heap.end(); ++it)
        {
            (*ret)[ i++] = it->first;
        }
        return ret;
    }

    static bool ObjValid( DObj ID)
    {
        ObjHeapT::iterator it=objHeap.find( ID);
        return  (it != objHeap.end());
    }

    static SizeT ObjHeapSize()
    {
        return objHeap.size();
    }

//     static DObj FindInObjHeap( BaseGDL** p)
//     {
//         for( ObjHeapT::iterator it=objHeap.begin(); it != objHeap.end(); ++it)
//         {
//             if( &it->second == reinterpret_cast<DStructGDL**>(p))
//                 return it->first;
//         }
//         return 0;
//     }
    static DObjGDL* GetAllObjHeap()
    {
        SizeT nEl = objHeap.size();
        if( nEl == 0) return new DObjGDL( 0);
        DObjGDL* ret = new DObjGDL( dimension( &nEl, 1), BaseGDL::NOZERO);
        SizeT i=0;
        for( ObjHeapT::iterator it=objHeap.begin(); it != objHeap.end(); ++it)
        {
            IncRefObj( it->first);
            (*ret)[ i++] = it->first;
        }
        return ret;
    }

    // no ref counting here
    static std::vector<DObj>* GetAllObjHeapSTL()
    {
        SizeT nEl = objHeap.size();
        if( nEl == 0) return new std::vector<DObj>();
        std::vector<DObj>* ret = new std::vector<DObj>( nEl);
        SizeT i=0;
        for( ObjHeapT::iterator it=objHeap.begin(); it != objHeap.end(); ++it)
        {
            (*ret)[ i++] = it->first;
        }
        return ret;
    }

    // name of data
    static const std::string Name( BaseGDL* p) // const
    {
        return callStack.back()->GetString( p);
    }

    static const std::string Name( BaseGDL** p) // const
    {
        assert( *p == NULL);
        DPtr h = FindInHeap( p);
        if( h != 0) return std::string("<PtrHeapVar")+i2s(h)+">";
//         DObj o = FindInObjHeap( p);
//         if( o != 0) return std::string("<ObjHeapVar")+i2s(o)+">";
        return "<(ptr to undefined expression not found on the heap)>";
    }

    // compiler (lexer, parser, treeparser) def in dinterpreter.cpp
    static void ReportCompileError( GDLException& e, const std::string& file = "");

    // interpreter
    static void ReportError( GDLException& e, const std::string emsg, 
                             bool dumpStack=true)
    {
        DString msgPrefix = SysVar::MsgPrefix();

        std::cout << std::flush;
        if( dumpStack)
        if( e.Prefix())
        {
            std::cerr << msgPrefix << e.toString() << std::endl;
            lib::write_journal_comment(msgPrefix+e.toString());
        }
        else
        {
            std::cerr << e.toString() << std::endl;
            lib::write_journal_comment(e.toString());
        }

        std::cerr << msgPrefix << emsg << " " << 
        std::left << std::setw(16) << callStack.back()->GetProName();
        std::string file=callStack.back()->GetFilename();
        if( file != "")
        {
            SizeT line = e.getLine();
            if( line != 0)
            {       
                std::cerr << std::right << std::setw(6) << line;
            }
            else
            {
                std::cerr << std::right << std::setw(6) << "";
            }
            std::cerr << std::left << " " << file;
        }
        std::cerr << std::endl;
        
        if( dumpStack) DumpStack( emsg.size() + 1);
    }
    
    static void DumpStack( SizeT w)
    {
        DString msgPrefix = SysVar::MsgPrefix();

        EnvStackT::reverse_iterator upEnv = callStack.rbegin();
        //EnvStackT::reverse_iterator env = upEnv++;
        upEnv++;
        for(; 
            upEnv != callStack.rend();
            ++upEnv /*,++env*/)
        {
            std::cerr << msgPrefix << std::right << std::setw( w) << "";
            std::cerr << std::left << std::setw(16) << (*upEnv)->GetProName();

            std::string file = (*upEnv)->GetFilename();
            if( file != "")
            {              
//                 ProgNodeP cNode= (*env)->CallingNode();
//                 if( cNode != NULL)
//                 {       
//                     std::cerr << std::right << std::setw(6) << cNode->getLine();
//                 }
//                 else
//                 {
//                     std::cerr << std::right << std::setw(6) << "";
//                 }                

//                 ProgNodeP cNode= (*env)->CallingNode();
//                 if( cNode != NULL && cNode->getLine() != 0)
//                 {       
//                     (*upEnv)->SetLineNumber( cNode->getLine());
//                 }

                int lineNumber = (*upEnv)->GetLineNumber();
                if( lineNumber != 0)
                {       
                    std::cerr << std::right << std::setw(6) << lineNumber;
                }
                else
                {
                    std::cerr << std::right << std::setw(6) << "";
                }
                std::cerr << std::left << " " << file;
            }
            std::cerr << std::endl;
        }
    }

    static void DebugMsg( ProgNodeP _t, const std::string& msg)
    {    
        DString msgPrefix = SysVar::MsgPrefix();

        std::cout << std::flush;
        std::cerr << msgPrefix << msg
        << std::left << std::setw(16) << callStack.back()->GetProName();
        std::string file=callStack.back()->GetFilename();
        if( file != "")
        {
            ProgNodeP eNode = _t;
            if( eNode != NULL)
            {       
                std::cerr << std::right << std::setw(6) << eNode->getLine();
            }
            else
            {
                std::cerr << std::right << std::setw(6) << "";
            }
            std::cerr << std::left << " " << file;
        }
        std::cerr << std::endl;
    }

    static void RetAll( RetAllException::ExCode c=RetAllException::NONE)    
    {
        throw RetAllException( c);
    }

    static EnvStackT& CallStack() { return callStack;} // the callstack
    static EnvBaseT*  CallStackBack() { return callStack.back();} 
    
    std::string GetClearActualLine()
    {
        std::string ret = executeLine.str();
        executeLine.str("");
        return ret;
    }

    RetCode NewInterpreterInstance(SizeT lineOffset); // code in dinterpreter.cpp

    ~GDLInterpreter()
    {
    }
}

//***********************************************************************
// interpreter functions ************************************************
//***********************************************************************

// intercative usage
interactive returns[ GDLInterpreter::RetCode retCode]
// {
// 	return interactive_statement_list(_t);
// }    
//     : retCode=statement_list
//     ;
// // used from interactive nulls line number
// interactive_statement_list returns[ GDLInterpreter::RetCode retCode]
{
	for (; _t != NULL;) {

        _t->setLine(0);
		retCode=statement(_t);
		_t = _retTree;
			
		if( retCode != RC_OK) break; // break out if non-regular
	}
	_retTree = _t;
	return retCode;
}
    : (retCode=statement
            {
                if( retCode != RC_OK) break; // break out if non-regular
            }
        )+
    ;

// execute statement
execute returns[ GDLInterpreter::RetCode retCode]
{
//    GDLInterpreter::RetCode retCode;
    ValueGuard<bool> guard( interruptEnable);
    interruptEnable = false;

	return statement_list(_t);
}
    : retCode=statement_list
    ;

// used to call functions
// same as statement list, but different behaviour for returncodes
call_fun returns[ BaseGDL* res]
{

    res = NULL;
    returnValue = NULL;
    GDLInterpreter::RetCode retCode;

	for (; _t != NULL;) {

			retCode=statement(_t);
			_t = _retTree;
			
// 			if( retCode == RC_RETURN) 
			if( retCode >= RC_RETURN) 
			{
			res=returnValue;
			returnValue=NULL;
			
			break;
			}
					
	}
	
	// default return value if none was set
	if( res == NULL) res = new DIntGDL( 0); 
	
	_retTree = _t;
	return res;
}
    : (retCode=statement
            {
//                if( retCode == RC_RETURN) 
                if( retCode >= RC_RETURN) 
                {
                    res=returnValue;
                    returnValue=NULL;
                    
                    break;
                }
            }
        )*
        {
            // default return value if none was set
            if( res == NULL) res = new DIntGDL( 0); 
        }
    ;

call_lfun returns[ BaseGDL** res]
{
    res = NULL;
    returnValueL = NULL;
    GDLInterpreter::RetCode retCode;

	ProgNodeP in = _t;

	for (; _t != NULL;) {
			retCode=statement(_t);
			_t = _retTree;
			
//			if( retCode == RC_RETURN) 
			if( retCode >= RC_RETURN) 
			{
			res=returnValueL;
			returnValueL=NULL;
			break;
			}
			
	}
	
	// default return value if none was set
	if( res == NULL)
	throw GDLException( in, "Function "+
	callStack.back()->GetProName()+
	" must return a left-value in this context.",false,false);
	
	_retTree = _t;
	return res;
}
    : (retCode=statement
            {
//                if( retCode == RC_RETURN) 
                if( retCode >= RC_RETURN) 
                {
                    res=returnValueL;
                    returnValueL=NULL;
                    break;
                }
            }
        )*
        {
            // default return value if none was set
            if( res == NULL)
            throw GDLException( call_lfun_AST_in, "Function "+
                callStack.back()->GetProName()+
                " must return a left-value in this context.",false,false);
        }
    ;

// used to call procedures
call_pro
{
    GDLInterpreter::RetCode retCode;

	for (; _t != NULL;) {
			retCode=statement(_t);
			_t = _retTree;
			
			// added RC_ABORT here
			if( retCode >= RC_RETURN) break;
	}
	_retTree = _t;
    return;
}
    : (retCode=statement
            {
                // added RC_ABORT here
                if( retCode >= RC_RETURN) break;
            }
        )*
    ;


// used on many occasions
statement_list returns[ GDLInterpreter::RetCode retCode]
{
	for (; _t != NULL;) {

		retCode=statement(_t);
		_t = _retTree;
			
		if( retCode != RC_OK) break; // break out if non-regular
	}
	_retTree = _t;
	return retCode;
}
    : (retCode=statement
            {
                if( retCode != RC_OK) break; // break out if non-regular
            }
        )+
    ;

statement returns[ GDLInterpreter::RetCode retCode]
{
    retCode = RC_OK;
    ProgNodeP actPos = _t;
    assert( _t != NULL);
//     if( callStack.back()->GetLineNumber() == 0) 
    if( _t->getLine() != 0) 
        callStack.back()->SetLineNumber( _t->getLine());
}
	: (
            // note: assignment must take care to update the owner of lvalue
            // a real copy must be performed (creating a new BaseGDL)  
            a:ASSIGN            
            {a->Run();}
        |   ac:ASSIGN_ARRAYEXPR_MFCALL
            {ac->Run();}
        |   r:ASSIGN_REPLACE            
            {r->Run();}
            //            assignment
        |   l:PCALL_LIB
            {l->Run();}
        |   m:MPCALL
            {m->Run();}
        |   mp:MPCALL_PARENT
            {mp->Run();}
        |   p:PCALL
            {p->Run();}
            // procedure_call
            //        |   lib_procedure_call
        |   d:DEC
            {d->Run();}
        |   i:INC
            {i->Run();}
            // decinc_statement
        |   retCode=for_statement 
        |   retCode=foreach_statement 
        |   retCode=repeat_statement
        |   retCode=while_statement
        |   retCode=if_statement
        |   retCode=if_else_statement
        |   retCode=case_statement
        |   retCode=switch_statement
        |   retCode=block
        |   retCode=jump_statement
        |   LABEL
        |   ON_IOERROR_NULL
            {
                static_cast<EnvUDT*>(callStack.back())->SetIOError( -1);
            }
        |   o:ON_IOERROR
            {
                static_cast<EnvUDT*>(callStack.back())->
                    SetIOError( o->targetIx);
            }
        )
        // control c and debugging
        {
           // possible optimization: make sigControlC a debugMode 
           if( interruptEnable && sigControlC)
            {
                DebugMsg( actPos, "Interrupted at: "); 

                sigControlC = false;

                retCode = NewInterpreterInstance(actPos->getLine()-1);
            }
            else if( debugMode != DEBUG_CLEAR)
            {
                if( debugMode == DEBUG_STOP)
                {
                    DebugMsg( actPos, "Stop encoutered: ");
                    if( !interruptEnable)
                        debugMode = DEBUG_PROCESS_STOP;
                }

                if( interruptEnable)
                {
                    if( debugMode == DEBUG_PROCESS_STOP)
                    {
                        DebugMsg( actPos, "Stepped to: ");
                    }

                    debugMode = DEBUG_CLEAR;
                
                    retCode = NewInterpreterInstance(actPos->getLine()-1);
                }   
                else
                {
                    retCode = RC_ABORT;
                }
            }
        }
	;
    exception 
    catch [ GDLException& e] 
    { 
        if( dynamic_cast< GDLIOException*>( &e) != NULL)
            {
                // set the jump target - also logs the jump
                ProgNodeP onIOErr = static_cast<EnvUDT*>(callStack.back())->GetIOError();
                if( onIOErr != NULL)
                    {
                        SysVar::SetErr_String( e.getMessage());
                        _t = onIOErr;
                        retCode=RC_OK;		

                        _retTree = _t;
                        return retCode;
                    }
            }

        EnvUDT* targetEnv = e.GetTargetEnv();
        if( targetEnv == NULL)
        {
            // initial exception, set target env
            // look if ON_ERROR is set somewhere
            for( EnvStackT::reverse_iterator i = callStack.rbegin();
                i != callStack.rend(); ++i)
            {
                DLong oE = static_cast<EnvUDT*>(*i)->GetOnError();
                
                if( oE != -1) 
                { // oE was set
                    
                    // 0 -> stop here
                    if( oE == 0) 
                    targetEnv = static_cast<EnvUDT*>(callStack.back()); 
                    // 1 -> $MAIN$
                    else if( oE == 1) 
                    {
                        EnvUDT* cS_begin = 
                        static_cast<EnvUDT*>(*callStack.begin());
                        targetEnv = cS_begin;  
                    }
                    // 2 -> caller of routine which called ON_ERROR
                    else if( oE == 2)
                    {
                        // set to caller, handle nested
                        while( static_cast<EnvUDT*>(*(++i))->GetOnError() == 2 
                               && i != callStack.rend());

                        if( i == callStack.rend())
                        {
                            EnvUDT* cS_begin = 
                            static_cast<EnvUDT*>(*callStack.begin());
                            targetEnv = cS_begin;
                        }
                        else
                        {
                            EnvUDT* iUDT = static_cast<EnvUDT*>(*i);
                            targetEnv = iUDT;
                        }
                    }   
                    // 3 -> routine which called ON_ERROR
                    else if( oE == 3)
                    {
                        EnvUDT* iUDT = static_cast<EnvUDT*>(*i);
                        targetEnv = iUDT;
                    }
                    
                    
                    // State where error occured
//                     if( e.getLine() == 0 && _t != NULL)
//                         e.SetLine( _t->getLine());
//                     if( e.getLine() == 0 && _retTree != NULL)
//                         e.SetLine( _retTree->getLine());
                    if( e.getLine() == 0 && actPos != NULL)
                        e.SetLine( actPos->getLine());

                    ReportError(e, "Error occurred at:");

                    // remeber where to stop
                    e.SetTargetEnv( targetEnv);
                    
                    if( targetEnv->GetLineNumber() != 0)
                        e.SetLine( targetEnv->GetLineNumber());                    

//                     ProgNodeP errorNodeP = targetEnv->CallingNode();
//                     e.SetErrorNodeP( errorNodeP);

                    // break on first occurence of set oE
                    break;
                }
            }
        }
        
        if( targetEnv != NULL && targetEnv != callStack.back())
        {
            throw e; // rethrow
        }
        lib::write_journal( GetClearActualLine());

        // many low level routines don't have errorNode info
        // set line number here in this case
//         if( e.getLine() == 0 && _t != NULL)
//             e.SetLine( _t->getLine());
//         if( e.getLine() == 0 && _retTree != NULL)
//             e.SetLine( _retTree->getLine());
//        if( e.getLine() == 0 && actPos != NULL)
//            e.SetLine( actPos->getLine());

        if( interruptEnable)
            {
                // tell where we are
                ReportError(e, "Execution halted at:", targetEnv == NULL); 

                retCode = NewInterpreterInstance(e.getLine()-1);
            }    
        else
            {

                DString msgPrefix = SysVar::MsgPrefix();
                if( e.Prefix())
                    {
                        std::cerr << msgPrefix << e.toString() << std::endl;
                        lib::write_journal_comment(msgPrefix+e.toString());
                    }
                else
                    {
                        std::cerr << e.toString() << std::endl;
                        lib::write_journal_comment(e.toString());
                    }

                retCode = RC_ABORT;
            }
    }

block returns[ GDLInterpreter::RetCode retCode]
{
    retCode = RC_OK;

	ProgNodeP block = _t;
	match(antlr::RefAST(_t),BLOCK);
	_t = _t->getFirstChild();
	if (_t != NULL)
		{

            SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();

            retCode=statement_list(_t);

            if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
                !block->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
                {
                    // a jump (goto) occured out of this block
                    return retCode;
                }
		}
	_retTree = block->getNextSibling();
	return retCode;
}
	: #(BLOCK (retCode=statement_list)?)
	;

switch_statement returns[ GDLInterpreter::RetCode retCode]
{
    BaseGDL* e;
    retCode = RC_OK; // not set if no branch is executed
}
	: #(s:SWITCH e=expr 
            {
                auto_ptr<BaseGDL> e_guard(e);
                
                SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();

                ProgNodeP b=_t; // remeber block begin (block)

                bool hook=false; // switch executes everything after 1st match
                for( int i=0; i<s->numBranch; i++)
                {
                    if( b->getType() == ELSEBLK)
                    {
                        hook=true;

                        ProgNodeP sL = b->GetFirstChild(); // statement_list

                        if( sL != NULL )
                        {
                            // statement there
                            retCode=statement_list( sL);
                            if( retCode == RC_BREAK) 
                            {
                                retCode = RC_OK;    
                                break;          // break
                            }
                            if( retCode >= RC_RETURN) break; // goto

                            if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
                                !s->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
                            {
                                // a jump (goto) occured out of this loop
                                return retCode;
                            }

                        }
                    }
                    else
                    {
                        ProgNodeP ex = b->GetFirstChild();  // EXPR
                        ProgNodeP bb = ex->GetNextSibling(); // statement_list

                        if( !hook)
                        {
//                            RefDNode ee_ = _t->GetFirstChild(); // expr

                            BaseGDL* ee=expr(ex);
                            // auto_ptr<BaseGDL> ee_guard(ee);

                            hook=e->Equal(ee); // Equal deletes ee
                        }
                            
                        if(bb != NULL && hook)
                        {
                            // statement there
                            retCode=statement_list(bb);
                            if( retCode == RC_BREAK) 
                            {
                                retCode = RC_OK;    
                                break;          // break
                            }
                            if( retCode >= RC_RETURN) break; // goto

                            if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
                                !s->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
                            {
                                // a jump (goto) occured out of this loop
                                return retCode;
                            }
                        }
                        
                    }
                    b=b->GetNextSibling(); // next block
                }
                // finish or break
//                retCode=RC_OK; // clear RC_BREAK retCode
            }
        )
    ;

case_statement returns[ GDLInterpreter::RetCode retCode]
{
    BaseGDL* e;
    retCode = RC_OK; // not set if no branch is executed
}
	: #(c:CASE e=expr
            {
                auto_ptr<BaseGDL> e_guard(e);

                SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();

                if( !e->Scalar())
                throw GDLException( _t, "Expression must be a"
                    " scalar in this context: "+Name(e),true,false);

                ProgNodeP b=_t; // remeber block begin

                for( int i=0; i<c->numBranch; i++)
                {
                    if( b->getType() == ELSEBLK)
                    {
                        ProgNodeP sL = b->GetFirstChild(); // statement_list

                        if(sL != NULL )
                        {
                            // statement there
                            retCode=statement_list(sL);
                            //if( retCode == RC_BREAK) break; // break anyway
//                            if( retCode >= RC_RETURN) return retCode; 
                            if( retCode >= RC_RETURN) break;
                            
                            if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
                                !c->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
                            {
                                // a jump (goto) occured out of this loop
                                return retCode;
                            }

                        }
                        retCode = RC_OK;
                        break;
                    }
                    else
                    {
                        ProgNodeP ex = b->GetFirstChild();  // EXPR
                        ProgNodeP bb = ex->GetNextSibling(); // statement_list

                        BaseGDL* ee=expr(ex);
                        // auto_ptr<BaseGDL> ee_guard(ee);

                        bool equalexpr=e->Equal(ee); // Equal deletes ee

                        if( equalexpr)
                        {
                            if(bb != NULL)
                            {
                                // statement there
                                retCode=statement_list(bb);
                                //if( retCode == RC_BREAK) break; // break anyway
//                                if( retCode >= RC_RETURN) return retCode;
                                if( retCode >= RC_RETURN) break;

                                if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
                                    !c->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
                                {
                                    // a jump (goto) occured out of this loop
                                    return retCode;
                                }

                            }
                            retCode = RC_OK;
                            break;
                        }
                        
                    }
                    b=b->GetNextSibling(); // next block
                }
                // finish or break
//                retCode=RC_OK; // clear RC_BREAK retCode
            }
        )
	;

repeat_statement returns[ GDLInterpreter::RetCode retCode]
{
    retCode = RC_OK; // not set if no branch is executed
}
	: #(r:REPEAT // block expr
            {
                SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();

                // remember block and expr nodes
                ProgNodeP e =_t;
                ProgNodeP bb  = e->GetNextSibling();

//                 ProgNodeP bb =_t;
//                 ProgNodeP e  = bb->GetNextSibling();
//                 bb = bb->GetFirstChild();
                
                auto_ptr<BaseGDL> eVal;
                do {
                    if( bb != NULL)
                    {
                    retCode=statement_list(bb);

                    if( retCode == RC_CONTINUE)
                                {
                                retCode = RC_OK;
                                continue;  
                                }
                    if( retCode == RC_BREAK) 
                    {
                        retCode = RC_OK;
                        break;        
                    }
                    if( retCode >= RC_RETURN) break;
                    // if( retCode == RC_BREAK) break;        
                    // if( retCode >= RC_RETURN) return retCode;

                    if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
                        !r->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
                    {
                        // a jump (goto) occured out of this loop
                        return retCode;
                    }
                    }
                    eVal.reset( expr(e));
                } while( eVal.get()->False());
                
                // retCode=RC_OK; // clear RC_BREAK/RC_CONTINUE retCode
            }
        )
	;

while_statement returns[ GDLInterpreter::RetCode retCode]
{
    retCode = RC_OK;
}
	: #(w:WHILE // statement expr 
            {
                SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();

                ProgNodeP e = _t; //->GetFirstChild();  // expr
                ProgNodeP s = _t->GetNextSibling();     // statement

                auto_ptr< BaseGDL> eVal( expr( e));
                while( eVal.get()->True()) {
                    retCode=statement(s);

                    if( retCode == RC_CONTINUE) 
                                {
                                retCode = RC_OK;
                                continue;  
                                }
                    if( retCode == RC_BREAK) 
                    {
                        retCode = RC_OK;
                        break;        
                    }
                    if( retCode >= RC_RETURN) break;
                    
                    if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
                        !w->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
                    {
                        // a jump (goto) occured out of this loop
                        return retCode;
                    }

                    eVal.reset( expr( e));
                } 

                // retCode=RC_OK; // clear RC_BREAK/RC_CONTINUE retCode
            }
        )
	;

for_statement returns[ GDLInterpreter::RetCode retCode]
{
    BaseGDL** v;
    BaseGDL* s;
    BaseGDL* e;
    BaseGDL* st;
    retCode = RC_OK;
}
    : #(f:FOR // (VAR|VARPTR) expr expr 
            {
                ProgNodeP sv = _t;
            }
            v=l_simple_var
            s=expr e=expr
            {
                auto_ptr<BaseGDL> s_guard(s);
                auto_ptr<BaseGDL> e_guard(e);

                EnvUDT* callStack_back = 
                static_cast<EnvUDT*>(callStack.back());
                SizeT nJump = callStack_back->NJump();

                s->ForCheck( &e);
                e_guard.release();
                e_guard.reset(e);

                ProgNodeP b=_t; //->getFirstChild();
                
                // ASSIGNMENT used here also
                delete (*v);

// problem:
// EXECUTE may call DataListT.loc.resize(), as v points to the
// old sequence v might be invalidated -> segfault
// note that the value (*v) is preserved by resize()
                s_guard.release(); // s held in *v after this
                for((*v)=s; (*v)->ForCondUp( e); 
                    v=l_simple_var( sv), (*v)->ForAdd()) 
                {
//                    retCode=block(b);
                    if( b != NULL)
                    {
                        retCode=statement_list(b);
                    
                        if( retCode != RC_OK) // optimization
                        {
                            if( retCode == RC_CONTINUE) 
                                {
                                retCode = RC_OK;
                                continue;  
                                }
                            if( retCode == RC_BREAK) 
                            {
                                retCode = RC_OK;
                                break;        
                            }
                            if( retCode >= RC_RETURN) break;
                        }

                        if( (callStack_back->NJump() != nJump) &&
                            !f->LabelInRange( callStack_back->LastJump()))
                        {
                            // a jump (goto) occured out of this loop
                            return retCode;
                        }
                    }
                }
//                retCode=RC_OK; // clear RC_BREAK/RC_CONTINUE retCode
            }
        )
    | #(fs:FOR_STEP // (VAR|VARPTR) expr expr expr 
            {
                ProgNodeP sv = _t;
            }
            v=l_simple_var
            s=expr e=expr st=expr
            {
                auto_ptr<BaseGDL> s_guard(s);
                auto_ptr<BaseGDL> e_guard(e);
                auto_ptr<BaseGDL> st_guard(st);

                SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();

                s->ForCheck( &e, &st);
                e_guard.release();
                e_guard.reset(e);
                st_guard.release();
                st_guard.reset(st);
                
                ProgNodeP bs=_t;
                
                // ASSIGNMENT used here also
                delete (*v);
                
                if( st->Sgn() == -1) 
                {
                    s_guard.release();
                    for((*v)=s; (*v)->ForCondDown( e); 
                        v=l_simple_var( sv), (*v)->ForAdd(st))
                    {
                        if( bs != NULL)
                        {
                            retCode=statement_list(bs);
                            
                            if( retCode == RC_CONTINUE)
                                {
                                retCode = RC_OK;
                                continue;  
                                }
                            if( retCode == RC_BREAK) 
                            {
                                retCode = RC_OK;
                                break;        
                            }
                            if( retCode >= RC_RETURN) break;
                            
                            if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
                                !fs->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
                            {
                                // a jump (goto) occured out of this loop
                                return retCode;
                            }
                        }
                    }
                } 
                else
                {
                    s_guard.release();
                    for((*v)=s; (*v)->ForCondUp( e);
                        v=l_simple_var( sv), (*v)->ForAdd(st))
                        {
                        if( bs != NULL)
                        {
                            retCode=statement_list(bs);
                        
                            if( retCode == RC_CONTINUE)
                                {
                                retCode = RC_OK;
                                continue;  
                                }

                            if( retCode == RC_BREAK) 
                            {
                                retCode = RC_OK;
                                break;        
                            }
                            if( retCode >= RC_RETURN) break;
                            
                            if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
                                !fs->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
                            {
                                // a jump (goto) occured out of this loop
                                return retCode;
                            }
                        }
                    }
                }
            }
        )
	;



foreach_statement returns[ GDLInterpreter::RetCode retCode]
{
    BaseGDL** v;
    BaseGDL* s;
    retCode = RC_OK;
}
    : #(f:FOREACH // (VAR|VARPTR) expr expr 
            {
                ProgNodeP sv = _t;
            }
            v=l_simple_var
            s=expr
            {
                auto_ptr<BaseGDL> s_guard(s);
             
                EnvUDT* callStack_back = 
                static_cast<EnvUDT*>(callStack.back());
                SizeT nJump = callStack_back->NJump();

                ProgNodeP b=_t; //->getFirstChild();
                
                // ASSIGNMENT used here also
                delete (*v);

                SizeT nEl = s->N_Elements();
// problem:
// EXECUTE may call DataListT.loc.resize(), as v points to the
// old sequence v might be invalidated -> segfault
// note that the value (*v) is preserved by resize()
                for( SizeT i=0; i<nEl; ++i)
                {
//                  retCode=block(b);
                    v=l_simple_var( sv);
                    (*v) = s->NewIx( i);

                    if( b != NULL)
                    {
                        retCode=statement_list(b);
                    
                        if( retCode != RC_OK) // optimization
                        {
                            if( retCode == RC_CONTINUE) 
                                {
                                retCode = RC_OK;
                                continue;  
                                }
                            if( retCode == RC_BREAK) 
                            {
                                retCode = RC_OK;
                                break;        
                            }
                            if( retCode >= RC_RETURN) break;
                        }

                        if( (callStack_back->NJump() != nJump) &&
                            !f->LabelInRange( callStack_back->LastJump()))
                        {
                            // a jump (goto) occured out of this loop
                            return retCode;
                        }
                    }
                }
//                retCode=RC_OK; // clear RC_BREAK/RC_CONTINUE retCode
            }
        )
    ;



if_statement returns[ GDLInterpreter::RetCode retCode]
{
    BaseGDL* e;
    retCode = RC_OK; // not set if not executed
}
	: #(i:IF e=expr
            { 
                auto_ptr<BaseGDL> e_guard(e);

                SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();

                if( e->True())
                {
                    retCode=statement(_t);
//                    if( retCode != RC_OK) return retCode;

                        if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
                            !i->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
                        {
                            // a jump (goto) occured out of this loop
                            return retCode;
                        }
                }
            }
        )
	;   

if_else_statement returns[ GDLInterpreter::RetCode retCode]
{
    BaseGDL* e;
    retCode = RC_OK; // not set if not executed
}
	: #(i:IF_ELSE e=expr
            { 
                auto_ptr<BaseGDL> e_guard(e);

                SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();

                if( e->True())
                {
                    retCode=statement(_t);
//                    if( retCode != RC_OK) return retCode;

                    if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
                        !i->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
                    {
                        // a jump (goto) occured out of this loop
                        return retCode;
                    }
                }
                else
                {
                    _t=_t->GetNextSibling(); // jump over 1st statement
                    retCode=statement(_t);
//                    if( retCode != RC_OK) return retCode;

                    if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
                        !i->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
                    {
                        // a jump (goto) occured out of this loop
                        return retCode;
                    }
                }
            }
        )
	;   

// to be processed (to make sure it really returns)
jump_statement returns[ GDLInterpreter::RetCode retCode]
{
BaseGDL*  e;
BaseGDL** eL;
}
    : g:GOTO // target in g->gotoTarget; // pointer to an DNode (NO RefDNode)
        {
            // note that this version jumps 'dumb'
            // jumping into loops is legal, even then looping is not done

            // set the jump target - also logs the jump
            _t = static_cast<EnvUDT*>(callStack.back())->GotoTarget( g->targetIx);
            _t = _t->GetNextSibling();
            retCode=RC_OK;
        }
    | #(RETF ( { !static_cast<EnvUDT*>(callStack.back())->LFun()}? e=expr // expr -> r value
                {
                    delete returnValue;
                    returnValue=e;
                    retCode=RC_RETURN;
                    callStack.back()->RemoveLoc( e); // steal e from local list
                }
            | eL=l_ret_expr
                {
                    // returnValueL is otherwise owned
                    returnValueL=eL;
                    retCode=RC_RETURN;
                }
            )
        ) 
    | RETP
        {
            retCode=RC_RETURN;
        }
	| BREAK    // only in loops or switch_statement and case_statement
        {
            retCode=RC_BREAK;
        }
	| CONTINUE // only in loops
        {
            retCode=RC_CONTINUE;
        }
  ;

// procedure_call
// { 
//     // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
//     StackGuard<EnvStackT> guard(callStack);
//     BaseGDL *self;
//     EnvUDT*   newEnv;
// }
// 	: #(PCALL_LIB pl:IDENTIFIER
//             {
//                 EnvT* newEnv=new EnvT( pl, pl->libPro);//libProList[pl->proIx]);
//             }
//             parameter_def[ newEnv]
//             {
//                 // push environment onto call stack
//                 callStack.push_back(newEnv);

//                 // make the call
//                 static_cast<DLibPro*>(newEnv->GetPro())->Pro()(newEnv);
//             }   
//         )
//     |
//         (
//         ( #(MPCALL 
//                 self=expr mp:IDENTIFIER
//                 {  
//                     auto_ptr<BaseGDL> self_guard(self);
                    
//                     newEnv=new EnvUDT( mp, self);

//                     self_guard.release();
//                 }
//                 parameter_def[ newEnv]
//             )
//         | #(MPCALL_PARENT 
//                 self=expr parent:IDENTIFIER pp:IDENTIFIER
//                 {
//                     auto_ptr<BaseGDL> self_guard(self);
                    
//                     newEnv = new EnvUDT( pp, self, parent->getText());

//                     self_guard.release();
//                 }
//                 parameter_def[ newEnv]
//             )
//         | #(PCALL p:IDENTIFIER
//             {
//                 SetProIx( p);
            
//                 newEnv = new EnvUDT( p, proList[p->proIx]);
//             }
//             parameter_def[ newEnv]
//             )
//         )
//         {
//             // push environment onto call stack
//             callStack.push_back(newEnv);
            
//             // make the call
//             call_pro(static_cast<DSubUD*>(newEnv->GetPro())->GetTree());
//         }   
//         )
// 	;	

// assignment
// {
//     BaseGDL*  r;
//     BaseGDL** l;
//     auto_ptr<BaseGDL> r_guard;
// }
//     : #(ASSIGN 
// //             ( r=tmp_expr
// //                 {
// //                     r_guard.reset( r);
// //                 }
// //             | r=check_expr
// //                 {
// //                     if( !callStack.back()->Contains( r)) 
// //                         r_guard.reset( r);
// //                 }
// //             )
//             ( r=indexable_expr
//             | r=indexable_tmp_expr { r_guard.reset( r);}
//             | r=check_expr
//                 {
//                     if( !callStack.back()->Contains( r)) 
//                         r_guard.reset( r); // guard if no global data
//                 }
//             )

//             l=l_expr[ r]
// //             {
// //                 // no delete if assigned to itself
// //                 // only possible from lib function
// //                 if( (*l) == r || callStack.back()->Contains( r)) 
// //                     r_guard.release();
// //             }
//         )
// //     | #(ASSIGN_INPLACE // ;=, *=, ...
// //             {
// //                  ProgNodeP op = _t;
// //                 _t = _t->getNextSibling();
// //             }
// //             ( r=indexable_expr
// //             | r=indexable_tmp_expr { r_guard.reset( r);}
// //             | r=check_expr
// //                 {
// //                     if( !callStack.back()->Contains( r)) 
// //                         r_guard.reset( r); // guard if no global data
// //                 }
// //             )
// // // don't forget ASSIGN_EXPR!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// //             l=l_inplace_expr[ op, r]
// //         )
//     | #(ASSIGN_REPLACE 
//             ( r=tmp_expr
//                 {
//                     r_guard.reset( r);
//                 }
//             | r=check_expr
//                 {

//                     if( !callStack.back()->Contains( r)) 
//                         r_guard.reset( r);
//                 }
//             )m,
//             (
//               l=l_function_call   // FCALL_LIB, MFCALL, MFCALL_PARENT, FCALL
//             | l=l_deref           // DEREF
//             | l=l_simple_var      // VAR, VARPTR
//             )
//         {
//             if( r != (*l))
//             {
//                 delete *l;

//                 if( r_guard.get() == r)
//                   *l = r_guard.release();
//                 else  
//                   *l = r->Dup();
//             }
//         }
//         )
//     ;

// decinc_statement
// {
//     BaseGDL* l;
// }
//     : #(DEC l=l_decinc_expr[ DECSTATEMENT])
//     | #(INC l=l_decinc_expr[ INCSTATEMENT])
//     ;

// ***************************************************************************
// the expressions ***********************************************************
// ***************************************************************************

l_deref returns [BaseGDL** res]
{
    BaseGDL*       e1;
}
    : #(DEREF e1=expr 
            {
                auto_ptr<BaseGDL> e1_guard(e1);
                
                DPtrGDL* ptr=dynamic_cast<DPtrGDL*>(e1);
                if( ptr == NULL)
                throw GDLException( _t, "Pointer type required"
                    " in this context: "+Name(e1),true,false);
                DPtr sc; 
                if( !ptr->Scalar(sc))
                throw GDLException( _t, "Expression must be a "
                    "scalar in this context: "+Name(e1),true,false);
                if( sc == 0)
                throw GDLException( _t, "Unable to dereference"
                    " NULL pointer: "+Name(e1),true,false);
                
                try{
                    res = &GetHeap(sc);
                }
                catch( HeapException)
                {
                    throw GDLException( _t, "Invalid pointer: "+Name(e1),true,false);
                }
            }
        )
    ;

// return value from functions when used as l var
// used only from jump_statement and within itself
l_ret_expr returns [BaseGDL** res]
{
    BaseGDL*       e1;
}
    : res=l_deref
    | #(QUESTION e1=expr
            { 
                auto_ptr<BaseGDL> e1_guard(e1);
                if( e1->True())
                {
                    res=l_ret_expr(_t);
                }
                else
                {
                    _t=_t->GetNextSibling(); // jump over 1st expression
                    res=l_ret_expr(_t);
                }
            }
        ) // trinary operator
//    | #(EXPR res=l_ret_expr) // does not exist anymore
    | res=l_arrayexpr_mfcall_as_mfcall
    | res=l_function_call 
        { // here a local to the actual environment could be returned
            if( callStack.back()->IsLocalKW( res))
            throw GDLException( _t, 
                "Attempt to return indirectly a local variable "
                "from left-function.",true,false);
        }
    | varPtr:VARPTR // DNode.var   is ptr to common block variable
        {
            res=&varPtr->var->Data(); // returns BaseGDL* of var (DVar*) 
        }
    | var:VAR // DNode.varIx is index into functions/procedures environment
        {     // check if variable is non-local 
              // (because it will be invalid after return otherwise)
            if( !callStack.back()->GlobalKW(var->varIx))
            throw GDLException( _t, 
                "Attempt to return a non-global variable from left-function.",true,false);
            
            res=&callStack.back()->GetKW(var->varIx); 
        }
    | // here ASSIGN and ASSIGN_REPLACE are identical
      #(ASSIGN // can it occur at all?
            { 
                auto_ptr<BaseGDL> r_guard;
            } 
            ( e1=tmp_expr
                {
                    r_guard.reset( e1);
                }
            | e1=check_expr
                {
                    if( !callStack.back()->Contains( e1)) 
                        r_guard.reset( e1);
                }
            )
            res=l_ret_expr
            {
                if( e1 != (*res))
                    {
                    delete *res;
                    *res = e1;
                    }
                r_guard.release();
            }
        )
    | #(ASSIGN_ARRAYEXPR_MFCALL // here as return value of l_function
            { 
                auto_ptr<BaseGDL> r_guard;
            } 
            ( e1=tmp_expr
                {
                    r_guard.reset( e1);
                }
            | e1=check_expr
                {
                    if( !callStack.back()->Contains( e1)) 
                        r_guard.reset( e1);
                }
            )
            res=l_arrayexpr_mfcall_as_mfcall
            {
                if( e1 != (*res))
                    {
                    delete *res;
                    *res = e1;
                    }
                r_guard.release();
            }
        )
    | #(ASSIGN_REPLACE 
            { 
                auto_ptr<BaseGDL> r_guard;
            } 
            ( e1=tmp_expr
                {
                    r_guard.reset( e1);
                }
            | e1=check_expr
                {
                    if( !callStack.back()->Contains( e1)) 
                        r_guard.reset( e1);
                }
            )
            res=l_ret_expr
            {
                if( e1 != (*res))
                    {
                    delete *res;
                    *res = e1;
                    }
                r_guard.release();
            }
        )

    // the following are forbiden    
    | #(ARRAYEXPR
            {
                throw GDLException( _t, 
                    "Indexed expression not allowed as left-function"
                    " return value.",true,false);
            }
        )
    | #(DOT 
            {
                throw GDLException( _t, 
                    "Struct expression not allowed as left-function"
                    " return value.",true,false);
            }
        )
    | SYSVAR
        {
            throw GDLException( _t, 
                "System variable not allowed as left-function"
                " return value.",true,false);
        }
    | e1=r_expr
        {
            delete e1;
            throw GDLException( _t, 
                "Expression not allowed as left-function return value.",true,false);
        }
    | e1=constant_nocopy
        {
            throw GDLException( _t, 
                "Constant not allowed as left-function return value.",true,false);
        }
    ;

// l expressions for DEC/INC ********************************
// called from l_decinc_array_expr
l_decinc_indexable_expr [int dec_inc] returns [BaseGDL* res]
{
    BaseGDL** e;
}
//     : #(EXPR e = l_expr[ NULL])                       
//         {
//             res = *e;
//             if( res == NULL)
//             throw GDLException( _t, "Variable is undefined: "+Name(e));
//         }
//     | e=l_function_call
    : e=l_function_call
        {
            res = *e;
            if( res == NULL)
            throw GDLException( _t, "Variable is undefined: "+Name(e),true,false);
        }
    | e=l_deref 
        {
            res = *e;
            if( res == NULL)
            throw GDLException( _t, "Variable is undefined: "+Name(e),true,false);
        }
    | e=l_defined_simple_var { res = *e; } // no Dup here
    | e=l_sys_var { res = *e; }            // no Dup here
    ;

// called from l_decinc_expr
l_decinc_array_expr [int dec_inc] returns [BaseGDL* res]
{
    ArrayIndexListT* aL;
    BaseGDL*         e;
    ArrayIndexListGuard guard;

}
    : #(ARRAYEXPR 
            e=l_decinc_indexable_expr[ dec_inc]   
            aL=arrayindex_list)
        {
            guard.reset( aL); 
            aL->SetVariable( e);

            if( dec_inc == DECSTATEMENT) 
            {
                e->DecAt( aL); 
                res = NULL;
                break;
            }
            if( dec_inc == INCSTATEMENT)
            {
                e->IncAt( aL);
                res = NULL;
                break;
            }

            if( dec_inc == DEC) e->DecAt( aL); 
            else if( dec_inc == INC) e->IncAt( aL);
//
            res=e->Index( aL);

            if( dec_inc == POSTDEC) e->DecAt( aL);
            else if( dec_inc == POSTINC) e->IncAt( aL);
        }
    | e=l_decinc_indexable_expr[ dec_inc]
        {
            if( dec_inc == DECSTATEMENT) 
            {
                e->Dec(); 
                res = NULL;
                break;
            }
            if( dec_inc == INCSTATEMENT)
            {
                e->Inc();
                res = NULL;
                break;
            }

            if( dec_inc == DEC) e->Dec();
            else if( dec_inc == INC) e->Inc();
  //          
            res = e->Dup();
            
            if( dec_inc == POSTDEC) e->Dec();
            else if( dec_inc == POSTINC) e->Inc();
        }
    ;

// struct assignment
// MAIN function: called from l_decinc_expr
l_decinc_dot_expr [int dec_inc] returns [BaseGDL* res]
    : #(dot:DOT 
            { 
                SizeT nDot=dot->nDot;
                auto_ptr<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
            } 
            l_dot_array_expr[ aD.get()] 
            (tag_array_expr[ aD.get()] /* nDot times*/ )+ 
        )         
        {
            if( dec_inc == DECSTATEMENT) 
            {
                aD->Dec(); 
                res = NULL;
            }
            else if( dec_inc == INCSTATEMENT)
            {
                aD->Inc();
                res = NULL;
            }
            else
            {
                if( dec_inc == DEC) aD->Dec(); //*** aD->Assign( dec_inc);
                else if( dec_inc == INC) aD->Inc();
//                
                res=aD->Resolve();
                
                if( dec_inc == POSTDEC) aD->Dec();
                else if( dec_inc == POSTINC) aD->Inc();
            }
        }
    ;

// l_decinc_expr is only used in dec/inc statements and within itself
l_decinc_expr [int dec_inc] returns [BaseGDL* res]
{
    BaseGDL*       e1;
    ProgNodeP startNode = _t;
}
    : #(QUESTION e1=expr
            { 
                auto_ptr<BaseGDL> e1_guard(e1);

                if( e1->True())
                {
                    res=l_decinc_expr(_t, dec_inc);
                }
                else
                {
                    _t=_t->GetNextSibling(); // jump over 1st expression
                    res=l_decinc_expr(_t, dec_inc);
                }
            }
        ) // trinary operator
    | #(ASSIGN 
            { 
                auto_ptr<BaseGDL> r_guard;
            } 
//             ( e1=tmp_expr
//                 {
//                     r_guard.reset( e1);
//                 }
//             | e1=check_expr
//                 {
//                     if( !callStack.back()->Contains( e1)) 
//                         r_guard.reset( e1);
//                 }
//             )
            ( e1=indexable_expr
            | e1=indexable_tmp_expr { r_guard.reset( e1);}
            | e1=check_expr
                {
                    if( !callStack.back()->Contains( e1)) 
                        r_guard.reset( e1); // guard if no global data
                }
            )
            { 
                ProgNodeP l = _t;

                BaseGDL** tmp;
            } 
            tmp=l_expr[ e1] // assign
            {
                _t = l;
            }
            res=l_decinc_expr[ dec_inc]
        )
    | #(ASSIGN_ARRAYEXPR_MFCALL
            { 
                auto_ptr<BaseGDL> r_guard;
            } 
            ( e1=indexable_expr
            | e1=indexable_tmp_expr { r_guard.reset( e1);}
            | e1=check_expr
                {
                    if( !callStack.back()->Contains( e1)) 
                        r_guard.reset( e1); // guard if no global data
                }
            )
            { 
                ProgNodeP l = _t;

                BaseGDL** tmp;

                // try MFCALL
                try
                {
    
                    tmp=l_arrayexpr_mfcall_as_mfcall(l);
    
                    if( e1 != (*tmp))
                    {
                        delete *tmp;

                        if( r_guard.get() == e1)
                            *tmp = r_guard.release();
                        else          
                            *tmp = e1->Dup();
                    }

                    res=l_decinc_expr( l, dec_inc);
                }
                catch( GDLException& ex)
                {
                // try ARRAYEXPR
                    try
	                {
                        tmp=l_arrayexpr_mfcall_as_arrayexpr(l, e1);
	                }
                    catch( GDLException& ex2)
                    {
                        throw GDLException(ex.toString() + " or "+ex2.toString());
                    }

                    res=l_decinc_expr( l, dec_inc);
                }
            }
        )
    | #(ASSIGN_REPLACE 
            { 
                auto_ptr<BaseGDL> r_guard;
            } 
            ( e1=tmp_expr
                {
                    r_guard.reset( e1);
                }
            | e1=check_expr
                {
                    if( !callStack.back()->Contains( e1)) 
                        r_guard.reset( e1);
                }
            )
            { 
                ProgNodeP l = _t;

                BaseGDL** tmp;
            } 
//            tmp=l_expr[ e1] // assign
            (
              tmp=l_function_call   // FCALL_LIB, MFCALL, MFCALL_PARENT, FCALL
            | tmp=l_deref           // DEREF
            | tmp=l_simple_var      // VAR, VARPTR
            )
        {
            if( e1 != (*tmp))
            {
                delete *tmp;

                if( r_guard.get() == e1)
                  *tmp = r_guard.release();
                else  
                  *tmp = e1->Dup();
            }
        }
            {
                _t = l;
            }
            res=l_decinc_expr[ dec_inc]
        )
    | res=l_decinc_array_expr[ dec_inc]
    | #(ARRAYEXPR_MFCALL
        {
            ProgNodeP mark = _t;
            _t = _t->getNextSibling(); // step over DOT

            BaseGDL* self;
        }
            
        //BaseGDL** e = l_arrayexpr_mfcall_as_mfcall( _t);
        self=expr mp2:IDENTIFIER

        {  
                auto_ptr<BaseGDL> self_guard(self);
        
                EnvUDT* newEnv;

                try {
                    newEnv=new EnvUDT( self, mp2, "", true);
                    self_guard.release();
                }
                catch( GDLException& ex)
                {
                    _t = mark;

                    res=l_decinc_dot_expr(_t, dec_inc);

                    _retTree = startNode->getNextSibling();
                    return res;
                }   
        }    

        parameter_def[ newEnv]
        
        {
            // push environment onto call stack
            callStack.push_back(newEnv);
            
            // make the call
            BaseGDL** ee=call_lfun(static_cast<DSubUD*>(
                                  newEnv->GetPro())->GetTree());

            BaseGDL* e = *ee;
            if( e == NULL)
                throw GDLException( _t, "Variable is undefined: "+Name(ee),true,false);

            if( dec_inc == DECSTATEMENT) 
                {
                    e->Dec(); 
                    res = NULL;
                    _retTree = startNode->getNextSibling();
                    return res;
                }
            if( dec_inc == INCSTATEMENT)
                {
                    e->Inc();
                    res = NULL;
                    _retTree = startNode->getNextSibling();
                    return res;
                }

            if( dec_inc == DEC) e->Dec();
            else if( dec_inc == INC) e->Inc();
  //          
            res = e->Dup();
            
            if( dec_inc == POSTDEC) e->Dec();
            else if( dec_inc == POSTINC) e->Inc();

            _retTree = startNode->getNextSibling();
            return res;
        }   
        )
    | res=l_decinc_dot_expr[ dec_inc]
    | e1=r_expr
        {
            delete e1;
            throw GDLException( _t, 
                "Expression not allowed with decrement/increment operator.",true,false);
        }
    | e1=constant_nocopy
        {
            throw GDLException( _t, 
                "Constant not allowed with decrement/increment operator.",true,false);
        }
    ;

// l expressions for assignment *************************

// an indexable expression must be defined
l_indexable_expr returns [BaseGDL** res]
    : #(EXPR res=l_expr[ NULL]) // for l_dot_array_expr
        {
            if( *res == NULL)
            throw GDLException( _t, "Variable is undefined: "+Name(res),true,false);
        }
    | res=l_function_call
        {
            if( *res == NULL)
            throw GDLException( _t, "Variable is undefined: "+Name(res),true,false);
        }
    | res=l_arrayexpr_mfcall_as_mfcall 
        {
            if( *res == NULL)
            throw GDLException( _t, "Variable is undefined: "+Name(res),true,false);
        }
    | res=l_deref
        {
            if( *res == NULL)
            throw GDLException( _t, "Variable is undefined: "+Name(res),true,false);
        }
    | res=l_defined_simple_var                         
    | res=l_sys_var 
    ;

// called from l_expr
l_array_expr [BaseGDL* right] returns [BaseGDL** res]
{
    ArrayIndexListT* aL;
    ArrayIndexListGuard guard;
}
    : #(ARRAYEXPR res=l_indexable_expr aL=arrayindex_list { guard.reset(aL);})   
        {
            if( right == NULL)
            throw GDLException( _t, 
                "Indexed expression not allowed in this context.",true,false);

            aL->AssignAt( *res, right);

//             aL->SetVariable( *res);
            
//             if( (*res)->EqType( right))
//             {
//                 (*res)->AssignAt( right, aL); // assigns inplace
//             }
//             else
//             {
//                 BaseGDL* rConv = right->Convert2( (*res)->Type(), BaseGDL::COPY);
//                 auto_ptr<BaseGDL> conv_guard( rConv);
                
//                 (*res)->AssignAt( rConv, aL); // assigns inplace
//             }
        }
    ;

l_dot_array_expr [DotAccessDescT* aD] // 1st
{
    ArrayIndexListT* aL;
    BaseGDL**        rP;
    DStructGDL*      structR;
    ArrayIndexListGuard guard;
    bool isObj = callStack.back()->IsObject();
}
    : #(ARRAYEXPR rP=l_indexable_expr aL=arrayindex_list { guard.reset(aL);})   
        {
            // check here for object and get struct
            structR=dynamic_cast<DStructGDL*>(*rP);
            if( structR == NULL)
            {
                if( isObj)
                {
                    DStructGDL* oStruct = ObjectStructCheckAccess( *rP, _t);

                    // oStruct cannot be "Assoc_"
                    aD->Root( oStruct, guard.release()); 
                }
                else
                {
                    throw GDLException( _t, "Expression must be a"
                        " STRUCT in this context: "+Name(*rP),true,false);
                }
            }
            else 
            {
                if( (*rP)->IsAssoc())
                throw GDLException( _t, "File expression not allowed "
                    "in this context: "+Name(*rP),true,false);
                
                aD->Root( structR, guard.release() /* aL */); 
            }
        }
    | rP=l_indexable_expr
        {
            // check here for object and get struct
            structR = dynamic_cast<DStructGDL*>(*rP);
            if( structR == NULL)
            {
                if( isObj) // member access to object?
                {
                    DStructGDL* oStruct = ObjectStructCheckAccess( *rP, _t);

                    // oStruct cannot be "Assoc_"
                    aD->Root( oStruct); 
                }
                else
                {
                    throw GDLException( _t, "Expression must be a"
                        " STRUCT in this context: "+Name(*rP),true,false);
                }
            }
            else
            {
                if( (*rP)->IsAssoc())
                {
                    throw GDLException( _t, "File expression not allowed "
                        "in this context: "+Name(*rP),true,false);
                }
                
                aD->Root(structR); 
            }
        }
    ;


// l_expr is only used in assignment and within itself
l_expr [BaseGDL* right] returns [BaseGDL** res]
{
    BaseGDL*       e1;
}
    : #(QUESTION e1=expr
            { 
                auto_ptr<BaseGDL> e1_guard(e1);

                if( e1->True())
                {
                    res=l_expr(_t, right);
                }
                else
                {
                    _t=_t->GetNextSibling(); // jump over 1st expression
                    res=l_expr(_t, right);
                }
            }
        ) // trinary operator
    | #(ASSIGN //???e1=expr
//             { 
//                 auto_ptr<BaseGDL> r_guard;
//             } 
//             ( e1=tmp_expr
//                 {
//                     r_guard.reset( e1);
//                 }
//             | e1=check_expr
//                 {
//                     if( !callStack.back()->Contains( e1)) 
//                         r_guard.reset( e1);
//                 }
//             )
            ( e1=indexable_expr
            | e1=indexable_tmp_expr { delete e1;}
//            | e1=indexable_tmp_expr { r_guard.reset( e1);}
            | e1=check_expr
                {
                    if( !callStack.back()->Contains( e1)) 
                        delete e1; // guard if no global data
//                        r_guard.reset( e1); // guard if no global data
                }
            )

            res=l_expr[ right]
//             {
//                 if( (*res) == e1 || callStack.back()->Contains( e1)) 
//                     r_guard.release();
//             }
        )
    | #(ASSIGN_ARRAYEXPR_MFCALL
            ( e1=indexable_expr
            | e1=indexable_tmp_expr { delete e1;}
            | e1=check_expr
                {
                    if( !callStack.back()->Contains( e1)) 
                        delete e1; 
                }
            )
            { 
                ProgNodeP l = _t;

                // try MFCALL
                try
                {
    
                    res=l_arrayexpr_mfcall_as_mfcall( l);
    
                    if( right != (*res))
                    {
                        delete *res;
                        *res = right->Dup();
                    }
                }
                catch( GDLException& ex)
                {
                // try ARRAYEXPR
                    try
	                {
                        res=l_arrayexpr_mfcall_as_arrayexpr(l, right);
	                }
                    catch( GDLException& ex2)
                    {
                        throw GDLException(ex.toString() + " or "+ex2.toString());
                    }
                }
            }
        )
    | #(ASSIGN_REPLACE //???e1=expr
//             { 
//                 auto_ptr<BaseGDL> r_guard;
//             } 
            ( e1=tmp_expr
                {
                    delete e1;
//                    r_guard.reset( e1);
                }
            | e1=check_expr
                {
                    if( !callStack.back()->Contains( e1)) 
                        delete e1;
//                        r_guard.reset( e1);
                }
            )
            (
              res=l_function_call   // FCALL_LIB, MFCALL, MFCALL_PARENT, FCALL
            | res=l_deref           // DEREF
            | res=l_simple_var      // VAR, VARPTR
            )
        {
            if( right != (*res))
//            if( e1 != (*res))
            {
                delete *res;
//
//                if( r_guard.get() == e1)
//                  *res = r_guard.release();
//                else  
                  *res = right->Dup();
            }
        }
        )
    | res=l_array_expr[ right]
    | { ProgNodeP sysVar = _t;} // for error reporting
        res=l_sys_var // sysvars cannot change their type
        {
            if( right == NULL)
            throw GDLException( sysVar, 
                "System variable not allowed in this context.",true,false);
            
           auto_ptr<BaseGDL> conv_guard; //( rConv);
           BaseGDL* rConv = right;
           if( !(*res)->EqType( right))
            {
                rConv = right->Convert2( (*res)->Type(), 
                                                  BaseGDL::COPY);
                conv_guard.reset( rConv);
            }
 
            if( right->N_Elements() != 1 && 
                ((*res)->N_Elements() != right->N_Elements()))
            {
                throw GDLException( _t, "Conflicting data structures: <"+
                    right->TypeStr()+" "+right->Dim().ToString()+">, !"+ 
                    sysVar->getText(),true,false);
            }
            
            (*res)->AssignAt( rConv); // linear copy
        }
//   | res=l_indexoverwriteable_expr 
     | // can be called via QUESTION
       ( res=l_function_call   // FCALL_LIB, MFCALL, MFCALL_PARENT, FCALL
       | res=l_deref           // DEREF
       | res=l_simple_var      // VAR, VARPTR
       )
     {
            if( right != NULL && right != (*res))
            {
                delete *res;
                *res = right->Dup();
            }
     }
//         {
//             if( right != NULL && right != (*res))
//             {
//                 // only here non-inplace copy is done
//                 delete *res;
//                 *res = right->Dup();
//             }
//         }
    | res=l_arrayexpr_mfcall[ right]
//    | res=l_dot_expr[ right]
    | #(dot:DOT  // struct assignment
            { 
                SizeT nDot=dot->nDot;
                auto_ptr<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
            } 
            l_dot_array_expr[ aD.get()] 
            (tag_array_expr[ aD.get()] /* nDot times*/ )+ 
        )         
        {
            if( right == NULL)
            throw GDLException( _t, "Struct expression not allowed in this context.",true,false);
            
            aD->Assign( right);

            res=NULL;
        }
//    | { right == NULL}? res=l_function_call
    | e1=r_expr
        {
            delete e1;
            throw GDLException( _t, 
                "Expression not allowed as l-value.",true,false);
        }
    | e1=constant_nocopy
        {
            throw GDLException( _t, 
                "Constant not allowed as l-value.",true,false);
        }
    ;

// used in l_expr but also in parameter_def
l_simple_var returns [BaseGDL** res]
{
	assert( _t != NULL);

	if( _t->getType() == VAR)
	{
		ProgNodeP var = _t;
// 		match(antlr::RefAST(_t),VAR);
		_t = _t->getNextSibling();
		
		
		res=&callStack.back()->GetKW(var->varIx); 
		
	}
	else
	{
		ProgNodeP varPtr = _t;
// 		match(antlr::RefAST(_t),VARPTR);
		_t = _t->getNextSibling();
		
		res=&varPtr->var->Data(); // returns BaseGDL* of var (DVar*) 
		
	}

	_retTree = _t;
	return res;
}
    : var:VAR // DNode.varIx is index into functions/procedures environment
        {

            res=&callStack.back()->GetKW(var->varIx); 
        }
    | varPtr:VARPTR // DNode.var   is ptr to common block variable
        {
            res=&varPtr->var->Data(); // returns BaseGDL* of var (DVar*) 
        }
    ;

l_defined_simple_var returns [BaseGDL** res]
{
	if( _t->getType() == VAR)
	{
		var = _t;
// 		match(antlr::RefAST(_t),VAR);
		_t = _t->getNextSibling();
		
		res=&callStack.back()->GetKW(var->varIx); 
		if( *res == NULL)
		throw GDLException( var, "Variable is undefined: "+
		callStack.back()->GetString(var->varIx),true,false);
		
	}
	else
	{
		varPtr = _t;
// 		match(antlr::RefAST(_t),VARPTR);
		_t = _t->getNextSibling();
		
		res=&varPtr->var->Data(); // returns BaseGDL* of var (DVar*) 
		if( *res == NULL)
		throw GDLException( _t, "Variable is undefined: "+
		callStack.back()->GetString( *res),true,false);
		
	}
	_retTree = _t;
	return res;
}
    : var:VAR // DNode.varIx is index into functions/procedures environment
        {
            res=&callStack.back()->GetKW(var->varIx); 
            if( *res == NULL)
            throw GDLException( _t, "Variable is undefined: "+
                callStack.back()->GetString(var->varIx),true,false);
        }
    | varPtr:VARPTR // DNode.var   is ptr to common block variable
        {
            res=&varPtr->var->Data(); // returns BaseGDL* of var (DVar*) 
            if( *res == NULL)
            throw GDLException( _t, "Variable is undefined: "+
                callStack.back()->GetString( *res),true,false);
        }
    ;

l_sys_var returns [BaseGDL** res]
    : sysVar:SYSVAR  
        // ProgNodeP->getText() returns name which 
        // has to be searched 
        // in 'sysVarList' (objects.cpp) if ProgNodeP->var is NULL
        {
            if( sysVar->var == NULL) 
            {
                sysVar->var=FindInVarList(sysVarList,sysVar->getText());
                if( sysVar->var == NULL)		    
                throw GDLException( _t, "Not a legal system variable: !"+
                    sysVar->getText(),true,false);

                // note: this works, because system variables are never 
                //       passed by reference
                SizeT rdOnlySize = sysVarRdOnlyList.size();
                for( SizeT i=0; i<rdOnlySize; ++i)
                  if( sysVarRdOnlyList[ i] == sysVar->var)
                    throw GDLException( _t, 
                    "Attempt to write to a readonly variable: !"+
                    sysVar->getText(),true,false);
            }
            // system variables are always defined
            res=&sysVar->var->Data();
        }
    ;

// right expressions **********************************************************
// expressions which always only return a value
// expecting to delete any sub-expressions
r_expr returns [BaseGDL* res]
    : e:EXPR
        { res = e->Eval();}
    | a:ARRAYDEF
        { res = a->Eval(); _t=_retTree;}
//     | c:ARRAYDEF_CONST
//         { res = c->Eval(); _t=_retTree;}
    | s:STRUC
        { res = s->Eval(); _t=_retTree;}
    | n:NSTRUC
        { res = n->Eval(); _t=_retTree;}
    | r:NSTRUC_REF
        { res = r->Eval(); _t=_retTree;}
//     | res=array_def
//     | res=struct_def

// {
//     BaseGDL* e1;
//     BaseGDL* e2;
// }
//     :	#(NOT_OP e1=expr { res= e1->NotOp();} )
//     |	#(UMINUS e1=expr { res= e1->UMinus();} )
//     |	#(AND_OP e1=expr e2=expr)			// binary operators...
//         {
//             AdjustTypes(e1,e2);
//             if( e1->Scalar())
//             res= e2->AndOp(e1); // scalar+scalar or array+scalar
//             else
//             if( e2->Scalar())
//             res= e1->AndOpInv(e2); // array+scalar
//             else
//             if( e1->N_Elements() <= e2->N_Elements())
//             res= e1->AndOpInv(e2); // smaller_array + larger_array or same size
//             else
//             res= e2->AndOp(e1); // smaller + larger
//         }
//     |	#(OR_OP  e1=expr e2=expr)
//         {
//             AdjustTypes(e1,e2);
//             if( e1->Scalar())
//             res= e2->OrOp(e1); // scalar+scalar or array+scalar
//             else
//             if( e2->Scalar())
//             res= e1->OrOpInv(e2); // array+scalar
//             else
//             if( e1->N_Elements() <= e2->N_Elements())
//             res= e1->OrOpInv(e2); // smaller_array + larger_array or same size
//             else
//             res= e2->OrOp(e1); // smaller + larger
//         }
//     |	#(XOR_OP e1=expr e2=expr) // xor is only defined for integers
//         {
//             AdjustTypes(e1,e2);
//             if( e1->N_Elements() <= e2->N_Elements())
//             res= e1->XorOp(e2); // smaller_array + larger_array or same size
//             else
//             res= e2->XorOp(e1); // smaller + larger
//         }
//     |	#(EQ_OP e1=expr e2=expr)
//         {
//             AdjustTypes(e1,e2);
//             res=e1->EqOp(e2);
//         }
//     |	#(NE_OP e1=expr e2=expr)
//         {
//             AdjustTypes(e1,e2);
//             res=e1->NeOp(e2);
//         }
//     |	#(LE_OP e1=expr e2=expr)
//         {
//             AdjustTypes(e1,e2);
//             res=e1->LeOp(e2);
//         }
//     |	#(LT_OP e1=expr e2=expr)
//         {
//             AdjustTypes(e1,e2);
//             res=e1->LtOp(e2);
//         }
//     |	#(GE_OP e1=expr e2=expr)
//         {
//             AdjustTypes(e1,e2);
//             res=e1->GeOp(e2);
//         }
//     |	#(GT_OP e1=expr e2=expr)
//         {
//             AdjustTypes(e1,e2);
//             res=e1->GtOp(e2);
//         }
//     |	#(PLUS  e1=expr e2=expr)
//         {
//             AdjustTypes(e1,e2);
//             if( e1->Scalar())
//             res= e2->AddInv(e1); // scalar+scalar or array+scalar
//             else
//             if( e2->Scalar())
//             res= e1->Add(e2); // array+scalar
//             else
//             if( e1->N_Elements() <= e2->N_Elements())
//             res= e1->Add(e2); // smaller_array + larger_array or same size
//             else
//             res= e2->AddInv(e1); // smaller + larger
//         }
//     |	#(MINUS e1=expr e2=expr)
//         {
//             AdjustTypes(e1,e2);
//             if( e1->Scalar())
//             res= e2->SubInv(e1); // scalar+scalar or array+scalar
//             else
//             if( e2->Scalar())
//             res= e1->Sub(e2); // array+scalar
//             else
//             if( e1->N_Elements() <= e2->N_Elements())
//             res= e1->Sub(e2); // smaller_array + larger_array or same size
//             else
//             res= e2->SubInv(e1); // smaller + larger
//         }
//     |	#(LTMARK e1=expr e2=expr)
//         {
//             AdjustTypes(e1,e2);
//             if( e1->Scalar())
//             res= e2->LtMark(e1); // scalar+scalar or array+scalar
//             else
//             if( e2->Scalar())
//             res= e1->LtMark(e2); // array+scalar
//             else
//             if( e1->N_Elements() <= e2->N_Elements())
//             res= e1->LtMark(e2); // smaller_array + larger_array or same size
//             else
//             res= e2->LtMark(e1); // smaller + larger
//         }
//     |	#(GTMARK e1=expr e2=expr)
//         {
//             AdjustTypes(e1,e2);
//             if( e1->Scalar())
//             res= e2->GtMark(e1); // scalar+scalar or array+scalar
//             else
//             if( e2->Scalar())
//             res= e1->GtMark(e2); // array+scalar
//             else
//             if( e1->N_Elements() <= e2->N_Elements())
//             res= e1->GtMark(e2); // smaller_array + larger_array or same size
//             else
//             res= e2->GtMark(e1); // smaller + larger
//         }
//     |	#(ASTERIX e1=expr e2=expr)
//         {
//             AdjustTypes(e1,e2);
//             if( e1->Scalar())
//             res= e2->Mult(e1); // scalar+scalar or array+scalar
//             else
//             if( e2->Scalar())
//             res= e1->Mult(e2); // array+scalar
//             else
//             if( e1->N_Elements() <= e2->N_Elements())
//             res= e1->Mult(e2); // smaller_array + larger_array or same size
//             else
//             res= e2->Mult(e1); // smaller + larger
//         }
//     |	#(MATRIX_OP1 e1=expr e2=expr) // #
//         {
//             DType aTy=e1->Type();
//             DType bTy=e2->Type();
//             DType maxTy=(DTypeOrder[aTy] >= DTypeOrder[bTy])? aTy: bTy;

//             DType cTy=maxTy;
//             if( maxTy == BYTE || maxTy == INT)
//             cTy=LONG;
//             else if( maxTy == UINT)
//             cTy=ULONG;

//             if( aTy != cTy) e1=e1->Convert2( cTy);

//             AdjustTypes(e1,e2);
//             res=e1->MatrixOp(e2);
//         }
//     |	#(MATRIX_OP2 e1=expr e2=expr) // ##
//         {
//             DType aTy=e1->Type();
//             DType bTy=e2->Type();
//             DType maxTy=(DTypeOrder[aTy] >= DTypeOrder[bTy])? aTy: bTy;

//             DType cTy=maxTy;
//             if( maxTy == BYTE || maxTy == INT)
//             cTy=LONG;
//             else if( maxTy == UINT)
//             cTy=ULONG;

//             if( aTy != cTy) e1=e1->Convert2( cTy);

//             AdjustTypes(e1,e2);
//             res=e2->MatrixOp(e1);
//         }
//     |	#(SLASH e1=expr e2=expr)
//         {
//             AdjustTypes(e1,e2);
//             if( e1->Scalar())
//             res= e2->DivInv(e1); // scalar+scalar or array+scalar
//             else
//             if( e2->Scalar())
//             res= e1->Div(e2); // array+scalar
//             else
//             if( e1->N_Elements() <= e2->N_Elements())
//             res= e1->Div(e2); // smaller_array + larger_array or same size
//             else
//             res= e2->DivInv(e1); // smaller + larger
//         }
//     |	#(MOD_OP e1=expr e2=expr)
//         {
//             AdjustTypes(e1,e2);
//             if( e1->Scalar())
//             res= e2->ModInv(e1); // scalar+scalar or array+scalar
//             else
//             if( e2->Scalar())
//             res= e1->Mod(e2); // array+scalar
//             else
//             if( e1->N_Elements() <= e2->N_Elements())
//             res= e1->Mod(e2); // smaller_array + larger_array or same size
//             else
//             res= e2->ModInv(e1); // smaller + larger
//         }
//     |	#(POW e1=expr e2=expr)
//         {
//            // special handling for complex
//             DType aTy=e1->Type();
//             if( aTy == COMPLEX)
//             {
//                 DType bTy=e2->Type();
//                 if( IntType( bTy))
//                 {
//                     e2 = e2->Convert2( FLOAT);
//                     res = e1->Pow( e2);
//                     goto endPOW;
//                 }
//                 else if( bTy == FLOAT)
//                 {
//                     res = e1->Pow( e2);
//                     goto endPOW;
//                 }
//             }
//             else if( aTy == COMPLEXDBL)
//             {
//                 DType bTy=e2->Type();
//                 if( IntType( bTy))
//                 {
//                     e2 = e2->Convert2( DOUBLE);
//                     res = e1->Pow( e2);
//                     goto endPOW;
//                 }
//                 else if( bTy == DOUBLE)
//                 {
//                     res = e1->Pow( e2);
//                     goto endPOW;
//                 }
//             }

//             DType convertBackT; 

//             // convert back
//             if( IntType( e2->Type()) && 
//                 DTypeOrder[e2->Type()] > DTypeOrder[e1->Type()])
//                 convertBackT = e1->Type();
//             else
//                 convertBackT = UNDEF;

//             AdjustTypes(e2,e1); // order crucial here (for converting back)

//             if( e1->Scalar())
//             res= e2->PowInv(e1); // scalar+scalar or array+scalar
//             else
//             if( e2->Scalar())
//             res= e1->Pow(e2); // array+scalar
//             else
//             if( e1->N_Elements() <= e2->N_Elements())
//             res= e1->Pow(e2); // smaller_array + larger_array or same size
//             else
//             res= e2->PowInv(e1); // smaller + larger
//             if( convertBackT != UNDEF)
//             {
//                 res = res->Convert2( convertBackT, BaseGDL::CONVERT);
//             }
//             endPOW:
//         }
    |	#(DEC res=l_decinc_expr[ DEC])
    |	#(INC res=l_decinc_expr[ INC])
    |	#(POSTDEC res=l_decinc_expr[ POSTDEC])
    |	#(POSTINC res=l_decinc_expr[ POSTINC])
//     // logical expressions
//     |   #(LOG_AND e1=expr e2=expr)
//         {
//             if( !e1->LogTrue()) {res = new DByteGDL( 0); break;}
//             if( !e2->LogTrue()) {res = new DByteGDL( 0); break;}
//             res = new DByteGDL( 1);
//         }
//     |   #(LOG_OR e1=expr e2=expr)
//         {
//             if( e1->LogTrue()) {res = new DByteGDL( 1); break;}
//             if( e2->LogTrue()) {res = new DByteGDL( 1); break;}
//             res = new DByteGDL( 0);
//         }
//     |   #(LOG_NEG e1=expr)
//         {
//             res = e1->LogNeg();
//         }
//    | res=constant
    ;

array_expr returns [BaseGDL* res]
{
    ArrayIndexListT* aL;
    BaseGDL* r;
    ArrayIndexListGuard guard;
    auto_ptr<BaseGDL> r_guard;

    ExprListT        exprList; // for cleanup
    IxExprListT      ixExprList;
    SizeT nExpr;
    BaseGDL* s;
}
    : #(ARRAYEXPR 
            ( r=indexable_expr
            | r=indexable_tmp_expr { r_guard.reset( r);}
            | r=check_expr
                {
                    if( !callStack.back()->Contains( r)) 
                        r_guard.reset( r); // guard if no global data
                }
            )
            //            aL=indexing_list { guard.reset(aL);}
        #(ax:ARRAYIX
                {
                    aL = ax->arrIxList;
                    assert( aL != NULL);
                    
                    guard.reset(aL);
                    
                    nExpr = aL->NParam();

                    if( nExpr == 0)
                    {
                        goto empty;
                    }
                    //                 if( nExpr > 1)
                    //                 {
                    //                     ixExprList.reserve( nExpr);
                    //                     exprList.reserve( nExpr);
                    //                 }
                    //                if( nExpr == 0) goto empty;
                }
                (
                    ( s=indexable_expr
                    | s=check_expr
                        {
                            if( !callStack.back()->Contains( s)) 
                            exprList.push_back( s);
                        }
                    | s=indexable_tmp_expr { exprList.push_back( s);}
                    )
                    {
                        ixExprList.push_back( s);
                        if( ixExprList.size() == nExpr)
                        break; // allows some manual tuning
                    }
                )*
                //            { empty: ;}
            )
            {
empty:
                //_retTree = ax;
                res = aL->Index( r, ixExprList);
//                 aL->Init( ixExprList);
//                 aL->SetVariable( r);
//                 res=r->Index( aL);
//                ClearTmpList();
            }
        )   
//     | res=expr //indexable_expr
    ;

// for l and r expr
tag_expr [DotAccessDescT* aD] // 2nd...
{
    BaseGDL* e;
}
    : #(EXPR e=expr
            {
                auto_ptr<BaseGDL> e_guard(e);
                
                SizeT tagIx;
                int ret=e->Scalar2index(tagIx);
                if( ret < 1)
                throw GDLException( _t, "Expression must be a scalar"
                    " >= 0 in this context: "+Name(e),true,false);
                
                aD->Add( tagIx);
            }
        )                       
    | i:IDENTIFIER
        {
            std::string tagName=i->getText();
            aD->Add( tagName);
        }
    ;

// for l and r expr
tag_array_expr  [DotAccessDescT* aD] // 2nd...
{
    ArrayIndexListT* aL;
}
	: #(ARRAYEXPR tag_expr[ aD] aL=arrayindex_list { aD->AddIx(aL);} )
    | tag_expr[ aD] { aD->AddIx(NULL);} 
    ;

r_dot_indexable_expr [DotAccessDescT* aD] returns [BaseGDL* res] // 1st
{
    BaseGDL** e;
}
    : #(EXPR res=expr { aD->SetOwner( true);}) // ({tag:0}).tag should work 
    | e=l_defined_simple_var { res = *e;}
    |   // we cant use l_sys_var here because of copy protection
        // could use sysvar and SetOwner( true), but this is quicker
        res=sys_var_nocopy // system variables are always defined    
    ;

r_dot_array_expr [DotAccessDescT* aD] // 1st
{
    ArrayIndexListT* aL;
    BaseGDL*         r;
    DStructGDL*      structR;
    ArrayIndexListGuard guard;
    bool isObj = callStack.back()->IsObject();
}
// NOTE: r is owned by aD or a l_... (r must not be deleted here)
    : #(ARRAYEXPR r=r_dot_indexable_expr[ aD] 
            aL=arrayindex_list { guard.reset(aL);} )   
        {
            // check here for object and get struct
            structR=dynamic_cast<DStructGDL*>(r);
            if( structR == NULL)
            {
                if( isObj)
                {
                    DStructGDL* oStruct = ObjectStructCheckAccess( r, _t);
                    
//                    DStructGDL* obj = oStruct->Index( aL);

                    if( aD->IsOwner()) delete r; 
                    aD->SetOwner( false); // object struct, not owned
                    
                    aD->Root( oStruct, guard.release()); 
//                    aD->Root( obj); 

//                     BaseGDL* obj = r->Index( aL);
//                     auto_ptr<BaseGDL> objGuard( obj); // new object -> guard
                    
//                     DStructGDL* oStruct = ObjectStructCheckAccess( obj, _t);

//                     // oStruct cannot be "Assoc_"
//                     if( aD->IsOwner()) delete r; 
//                     aD->SetOwner( false); // object structs are never owned
//                     aD->Root( oStruct); 
                }
                else
                {
                    throw GDLException( _t, "Expression must be a"
                        " STRUCT in this context: "+Name(r),true,false);
                }
            }
            else
            {
                if( r->IsAssoc())
                throw GDLException( _t, "File expression not allowed "
                    "in this context: "+Name(r),true,false);
                
                aD->Root( structR, guard.release()); 
            }
        }
    | r=r_dot_indexable_expr[ aD]
        {
            // check here for object and get struct
            structR = dynamic_cast<DStructGDL*>(r);
            if( structR == NULL)
            {
                if( isObj) // memeber access to object?
                {
                    DStructGDL* oStruct = ObjectStructCheckAccess( r, _t);

                    // oStruct cannot be "Assoc_"
                    if( aD->IsOwner()) delete r;
                    aD->SetOwner( false); // object structs are never owned
                    aD->Root( oStruct); 
                }
                else
                {
                    throw GDLException( _t, "Expression must be a"
                        " STRUCT in this context: "+Name(r),true,false);
                }
            }
            else
            {
                if( r->IsAssoc())
                {
                    throw GDLException( _t, "File expression not allowed "
                        "in this context: "+Name(r),true,false);
                }
                
                aD->Root(structR); 
            }
        }
    ;

// Entry function for struct access
//#(DOT array_expr (tag_array_expr)+)                     
dot_expr returns [BaseGDL* res]
{

	ProgNodeP rTree = _t->getNextSibling();
	//ProgNodeP 
    dot = _t;
// 	match(antlr::RefAST(_t),DOT);
	_t = _t->getFirstChild();
	
	SizeT nDot=dot->nDot;
	auto_ptr<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
	
	r_dot_array_expr(_t, aD.get());
	_t = _retTree;
	for (; _t != NULL;) {
			tag_array_expr(_t, aD.get());
			_t = _retTree;
	}
	res= aD->Resolve();
	_retTree = rTree;
	return res;
}
    : #(dot:DOT 
//             { 
//                 SizeT nDot=dot->nDot;
//                 auto_ptr<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
//             } 
            r_dot_array_expr[ aD.get()] 
            (tag_array_expr[ aD.get()] /* nDot times*/ )+ 
        )         
//         { res= aD->Resolve();}
    ;

// indexable expressions are used to minimize copying of data
// ( via Dup())
// owned by caller
indexable_tmp_expr returns [BaseGDL* res]
{
    BaseGDL*  e1;
}
	: #(q:QUESTION 
            { res = q->Eval(); }
//                 e1=expr
//             { 
//                 auto_ptr<BaseGDL> e1_guard(e1);

//                 if( e1->True())
//                 {   
//                     res=expr(_t);
//                 }
//                 else
//                 {
//                     _t=_t->GetNextSibling(); // jump over 1st expression
//                     res=expr(_t);
//                 }
//             }
        ) // trinary operator
    | res=array_expr
    | res=dot_expr
    | res=assign_expr
    | res=function_call
    | res=r_expr
    | res=lib_function_call_retnew 
    ;

// not owned by caller 
indexable_expr returns [BaseGDL* res]
{
    BaseGDL** e2;
}
    : e2=l_defined_simple_var
        {
            res = *e2;
        }
    | res=sys_var_nocopy
    | res=constant_nocopy
    | e2=l_deref 
        { 
            if( *e2 == NULL)
            throw GDLException( _t, "Variable is undefined: "+Name(e2),true,false);
            res = *e2;
        }
    ;

// l_expr used as r_expr and true r_expr
expr returns [BaseGDL* res]
{
	
	assert( _t != NULL);

	if ( _t->getType() == FCALL_LIB) {
        BaseGDL* res=lib_function_call(_t);
		
		if( callStack.back()->Contains( res)) 
		res = res->Dup();

        return res;    		
	}
	else
	{
		return tmp_expr(_t);
	}
}
    : res=tmp_expr
    | res=check_expr
        {
            if( callStack.back()->Contains( res)) 
                res = res->Dup();
        }
    ;


check_expr returns [BaseGDL* res]
    : res=lib_function_call 
    ;

// l_expr used as r_expr and true r_expr
tmp_expr returns [BaseGDL* res]
{
    BaseGDL*  e1;
    BaseGDL** e2;
}
    : e2=l_deref 
        { 
            if( *e2 == NULL)
            throw GDLException( _t, "Variable is undefined: "+Name(e2),true,false);
            
            res = (*e2)->Dup();
        }
	| #(q:QUESTION 
            { res = q->Eval();}
//                 e1=expr
//             { 
//                 auto_ptr<BaseGDL> e1_guard(e1);

//                 if( e1->True())
//                 {
//                     res=expr(_t);
//                 }
//                 else
//                 {
//                     _t=_t->GetNextSibling(); // jump over 1st expression
//                     res=expr(_t);
//                 }
//             }
        ) // trinary operator
    | res=array_expr
    | res=dot_expr
    | res=assign_expr
    | res=function_call
    | res=r_expr
    | res=constant
        // *********
    | res=simple_var                         
    | res=sys_var 
    | res=lib_function_call_retnew 
    ;

assign_expr returns [BaseGDL* res]
{
    BaseGDL** l;
    BaseGDL*  r;

	ProgNodeP startNode = _t;
	if( _t->getType() == ASSIGN) 
	{
// 		match(antlr::RefAST(_t),ASSIGN);
		_t = _t->getFirstChild();
		
		auto_ptr<BaseGDL> r_guard;
		
		if( _t->getType() == FCALL_LIB)
		{
			res=check_expr(_t);
			_t = _retTree;
			
			if( !callStack.back()->Contains( res)) 
			r_guard.reset( res);
			
		}
        else
		{
			res=tmp_expr(_t);
			_t = _retTree;
			
			r_guard.reset( res);
			
		}
		
		l=l_expr(_t, res);
		_t = _retTree;
		
		if( r_guard.get() == res) // owner
		r_guard.release();
		else
		res = res->Dup();
		
	}
    else if( _t->getType() == ASSIGN_ARRAYEXPR_MFCALL) 
        {

		_t = _t->getFirstChild();
		
		auto_ptr<BaseGDL> r_guard;
		
		if( _t->getType() == FCALL_LIB)
		{
			res=check_expr(_t);
			_t = _retTree;
			
			if( !callStack.back()->Contains( res)) 
			r_guard.reset( res);
			
		}
        else
		{
			res=tmp_expr(_t);
			_t = _retTree;
			
			r_guard.reset( res);
			
		}

        ProgNodeP mark = _t;

        // try MFCALL
        try
            {
                l=l_arrayexpr_mfcall_as_mfcall( mark);
    
                if( res != (*l))
                    {
                        delete *l;
                        *l = res->Dup();     
		
                        if( r_guard.get() == res) // owner
                            {
                                r_guard.release(); 
                            }
                        else
                            res = res->Dup();
                    }
            }
        catch( GDLException& ex)
            {
                // try ARRAYEXPR
                try
	                {
                        l=l_arrayexpr_mfcall_as_arrayexpr(mark, res);

                        if( r_guard.get() == res) // owner
                            r_guard.release();
                        else
                            res = res->Dup();
	                }
                catch( GDLException& ex2)
                    {
                        throw GDLException(ex.toString() + " or "+ex2.toString());
                    }
            }

        }
    else
	{
// 		match(antlr::RefAST(_t),ASSIGN_REPLACE);
		_t = _t->getFirstChild();
		
		auto_ptr<BaseGDL> r_guard;
		
		if( _t->getType() == FCALL_LIB)
		{

			res=check_expr(_t);
			_t = _retTree;
			
			if( !callStack.back()->Contains( res)) 
			r_guard.reset( res);
			
		}
        else
		{
			res=tmp_expr(_t);
			_t = _retTree;
			
			r_guard.reset( res);
			
		}

		
		switch ( _t->getType()) {
		case DEREF:
		{
			l=l_deref(_t);
			_t = _retTree;
			break;
		}
		case VAR:
		case VARPTR:
		{
			l=l_simple_var(_t);
			_t = _retTree;
			break;
		}
		default:
		{
			l=l_function_call(_t);
			_t = _retTree;
			break;
		}
		}
		
		if( res != (*l))
		{
		delete *l;
		*l = res->Dup();     
		
		if( r_guard.get() == res) // owner
		{
		r_guard.release(); 
		}
		else
		res = res->Dup();
		}
    }

	_retTree = startNode->getNextSibling();
	return res;
}

    : #(ASSIGN 
            { 
                auto_ptr<BaseGDL> r_guard;
            } 
            ( res=tmp_expr
                {
                    r_guard.reset( res);
                }
            | res=check_expr
                {
                    if( !callStack.back()->Contains( res)) 
                        r_guard.reset( res);
                }
            )
            l=l_expr[ res]
            { 
                if( r_guard.get() == res) // owner
                    r_guard.release();
                else
                    res = res->Dup();
            } // here res is returned!
        )
    | #(ASSIGN_ARRAYEXPR_MFCALL
            { 
                auto_ptr<BaseGDL> r_guard;
            } 
            ( res=tmp_expr
                {
                    r_guard.reset( res);
                }
            | res=check_expr
                {
                    if( !callStack.back()->Contains( res)) 
                        r_guard.reset( res);
                }
            )
            l=l_expr[ res]
            { 
                if( r_guard.get() == res) // owner
                    r_guard.release();
                else
                    res = res->Dup();
            } // here res is returned!
        )
    | #(ASSIGN_REPLACE 
            { 
                auto_ptr<BaseGDL> r_guard;
            } 
            ( res=tmp_expr
                {
                    r_guard.reset( res);
                }
            | res=check_expr
                {
                    if( !callStack.back()->Contains( res)) 
                        r_guard.reset( res);
                }
            )
            (
              l=l_function_call   // FCALL_LIB, MFCALL, MFCALL_PARENT, FCALL
            | l=l_deref           // DEREF
            | l=l_simple_var      // VAR, VARPTR
            )
            {
                if( res != (*l))
                {
                delete *l;
                *l = res->Dup();     

                if( r_guard.get() == res) // owner
                {
                    r_guard.release(); 
                }
                else
                    res = res->Dup();
                }
            }
        )
    ;



simple_var returns [BaseGDL* res]
{
	assert( _t != NULL);

	if( _t->getType() == VAR)
	{
		ProgNodeP var = _t;
		match(antlr::RefAST(_t),VAR);
		_t = _t->getNextSibling();
		
		BaseGDL* vData=callStack.back()->GetKW( var->varIx);
		
		if( vData == NULL)
		throw GDLException( _t, "Variable is undefined: "+var->getText(),true,false);
		
		res=vData->Dup();
		
	}
	else // VARPTR
	{
		ProgNodeP varPtr = _t;
		match(antlr::RefAST(_t),VARPTR);
		_t = _t->getNextSibling();
		
		BaseGDL* vData=varPtr->var->Data();
		
		if( vData == NULL)
		throw GDLException( _t, "Common block variable is undefined.",true,false);
		
		res=vData->Dup();
		
	}

	_retTree = _t;
	return res;
}
    : var:VAR // DNode.varIx is index into functions/procedures environment
        {
            BaseGDL* vData=callStack.back()->GetKW( var->varIx);
            
            if( vData == NULL)
            throw GDLException( _t, "Variable is undefined: "+var->getText(),true,false);
            
            res=vData->Dup();
        }
    | varPtr:VARPTR // DNode.var   is ptr to common block variable
        {
            BaseGDL* vData=varPtr->var->Data();
            
            if( vData == NULL)
            throw GDLException( _t, "Common block variable is undefined.",true,false);
            
            res=vData->Dup();
        }
    ;

sys_var returns [BaseGDL* res]
{
	BaseGDL* sv = sys_var_nocopy(_t);
	//_t = _retTree;
	
	//BaseGDL* 
    res=sv->Dup();
	
	//_retTree = _t;
	return res;
}
    : sv=sys_var_nocopy 
        {
            res=sv->Dup();
        }
    ;

sys_var_nocopy returns [BaseGDL* res]
{
	ProgNodeP& sysVarRef = _t;
	
// 	match(antlr::RefAST(_t),SYSVAR);
	
	if( sysVarRef->var == NULL) 
	{
	sysVarRef->var=FindInVarList(sysVarList,sysVarRef->getText());
	if( sysVarRef->var == NULL)		    
	throw GDLException( _t, "Not a legal system variable: !"+
	sysVarRef->getText(),true,false);
	}
	
	if( sysVarRef->getText() == "STIME") SysVar::UpdateSTime();
	
	// note: system variables are always defined
	
	_retTree = _t->getNextSibling();;
	return sysVarRef->var->Data(); // no ->Dup()
}
    : sysVar:SYSVAR 
        // ProgNodeP->getText() returns name which has to be searched 
        // in 'sysVarList' (objects.cpp) if ProgNodeP->var is NULL
        {
            if( sysVar->var == NULL) 
            {
                sysVar->var=FindInVarList(sysVarList,sysVar->getText());
                if( sysVar->var == NULL)		    
                throw GDLException( _t, "Not a legal system variable: !"+
                                    sysVar->getText(),true,false);
            }

            if( sysVar->getText() == "STIME") SysVar::UpdateSTime();

            // system variables are always defined
            res=sysVar->var->Data(); // no ->Dup()
        }
    ;

constant returns [BaseGDL* res]
    : c:CONSTANT
        {
            res=c->cData->Dup(); 
        }
  ;

constant_nocopy returns [BaseGDL* res]
{

	//BaseGDL* 
    res = _t->cData; // no ->Dup(); 
		
	_retTree = _t->getNextSibling();
	return res;
}
    : c:CONSTANT
        {
            res=c->cData; // no ->Dup(); 
        }
  ;

lib_function_call returns[ BaseGDL* res]
{ 
    // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
    StackGuard<EnvStackT> guard(callStack);
	
	ProgNodeP rTree = _t->getNextSibling();
// 	match(antlr::RefAST(_t),FCALL_LIB);

// 	match(antlr::RefAST(_t),IDENTIFIER);

	ProgNodeP& fl = _t;
	EnvT* newEnv=new EnvT( fl, fl->libFun);//libFunList[fl->funIx]);
	
	parameter_def(_t->getFirstChild(), newEnv);
	
	// push id.pro onto call stack
	callStack.push_back(newEnv);
	// make the call
	//BaseGDL* 
    res=static_cast<DLibFun*>(newEnv->GetPro())->Fun()(newEnv);
	// *** MUST always return a defined expression
//    if( res == NULL)
//       throw GDLException( _t, "");


	_retTree = rTree;
	return res;
}
	: #(fll:FCALL_LIB //fll:IDENTIFIER
            {
                //EnvT* 
                newEnv=new EnvT( fll, fll->libFun);//libFunList[fl->funIx]);
            }
            parameter_def[ newEnv]
            {
                // push id.pro onto call stack
                callStack.push_back(newEnv);
                // make the call
                res=static_cast<DLibFun*>(newEnv->GetPro())->Fun()(newEnv);
                //*** MUST always return a defined expression
            }
        )
    ;    

lib_function_call_retnew returns[ BaseGDL* res]
{ 
    // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
    StackGuard<EnvStackT> guard(callStack);

	ProgNodeP rTree = _t->getNextSibling();

// 	match(antlr::RefAST(_t),FCALL_LIB_RETNEW);
//	_t = _t->getFirstChild();
// 	match(antlr::RefAST(_t),IDENTIFIER);
	EnvT* newEnv=new EnvT( _t, _t->libFun);//libFunList[fl->funIx]);

// 	_t =_t->getFirstChild();
	
// 	EnvT* newEnv=new EnvT( fl, fl->libFun);//libFunList[fl->funIx]);
	
	parameter_def(_t->getFirstChild(), newEnv);
	
	// push id.pro onto call stack
	callStack.push_back(newEnv);
	// make the call
	//BaseGDL* 
    res=static_cast<DLibFun*>(newEnv->GetPro())->Fun()(newEnv);
	//*** MUST always return a defined expression
	
	_retTree = rTree;
	return res;
}
	: #(fll:FCALL_LIB_RETNEW //fll:IDENTIFIER
            {
                //EnvT* 
                newEnv=new EnvT( fll, fll->libFun);//libFunList[fl->funIx]);
            }
            parameter_def[ newEnv]
            {
                // push id.pro onto call stack
                callStack.push_back(newEnv);
                // make the call
                res=static_cast<DLibFun*>(newEnv->GetPro())->Fun()(newEnv);
                //*** MUST always return a defined expression
            }
        )
    ;    


function_call returns[ BaseGDL* res]
{ 
    // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
    StackGuard<EnvStackT> guard(callStack);
    BaseGDL *self;
    EnvUDT*  newEnv;
    ProgNodeP startNode = _t;
    ProgNodeP mark;
}
    : ( 
          #(MFCALL 
                self=expr mp:IDENTIFIER
                {  
                    auto_ptr<BaseGDL> self_guard(self);
                    
                    newEnv=new EnvUDT( self, mp);

                    self_guard.release();
                }
                parameter_def[ newEnv]
            )
        | #(MFCALL_PARENT 
                self=expr parent:IDENTIFIER p:IDENTIFIER
                {
                    auto_ptr<BaseGDL> self_guard(self);
                    
                    newEnv=new EnvUDT( self, p,
                        parent->getText());

                    self_guard.release();
                }
                parameter_def[ newEnv]
            )
        | #(f:FCALL //f:IDENTIFIER
                {
                    SetFunIx( f);
                    
                    newEnv=new EnvUDT( f, funList[f->funIx]);
                }
                parameter_def[ newEnv]
            )
        | #(ARRAYEXPR_MFCALL
            {
                mark = _t;
                _t = _t->getNextSibling(); // skip DOT
            }

            self=expr mp2:IDENTIFIER

            {  
                auto_ptr<BaseGDL> self_guard(self);
        
                try {
                    newEnv=new EnvUDT( self, mp2);
                    self_guard.release();
                }
                catch( GDLException& ex)
                {
                    goto tryARRAYEXPR;
                }
            } 

            parameter_def[ newEnv]
            )
        )        
            {
                // push environment onto call stack
                callStack.push_back(newEnv);
            
                // make the call
                res=call_fun(static_cast<DSubUD*>(newEnv->GetPro())->GetTree());

                _retTree = startNode->getNextSibling();
                return res;

                tryARRAYEXPR:;
                //_t = mark;

                ProgNodeP dot = mark;
                // 	match(antlr::RefAST(_t),DOT);
                _t = mark->getFirstChild();
	
                SizeT nDot=dot->nDot;
                auto_ptr<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
	
                r_dot_array_expr(_t, aD.get());
                _t = _retTree;
                for (; _t != NULL;) {
                    tag_array_expr(_t, aD.get());
                    _t = _retTree;
                }
                res= aD->Resolve();

                _retTree = startNode->getNextSibling();
                return res;
            }
	;	



l_arrayexpr_mfcall [BaseGDL* right] returns [BaseGDL** res]
{ 
    // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
    StackGuard<EnvStackT> guard(callStack);
    BaseGDL *self;
    EnvUDT*  newEnv;
    ProgNodeP startNode = _t;
}
    : #(ARRAYEXPR_MFCALL
        {
            ProgNodeP mark = _t;
            _t = _t->getNextSibling(); // skip DOT
        }

        self=expr mp2:IDENTIFIER

        {  
            auto_ptr<BaseGDL> self_guard(self);
        
            try {
                newEnv=new EnvUDT( self, mp2, "", true);
                self_guard.release();
            }
            catch( GDLException& ex)
            {
                goto tryARRAYEXPR;
            }
        }    

            parameter_def[ newEnv]
        )
        {
            // push environment onto call stack
            callStack.push_back(newEnv);
            
            // make the call
            res=call_lfun(static_cast<DSubUD*>(
                    newEnv->GetPro())->GetTree());

            _retTree = startNode->getNextSibling();
            return res;

            tryARRAYEXPR:;
            _t = mark;
        }   
        #(dot:DOT  // struct assignment
            { 
                SizeT nDot=dot->nDot;
                auto_ptr<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
            } 
            l_dot_array_expr[ aD.get()] 
            (tag_array_expr[ aD.get()] /* nDot times*/ )+ 
        )
        {
            if( right == NULL)
            throw GDLException( _t, 
                                "Struct expression not allowed in this context.",
                                true,false);
            
            aD->Assign( right);

            res=NULL;

            _retTree = startNode->getNextSibling();
            return res;
        }
    ;



l_arrayexpr_mfcall_as_arrayexpr [BaseGDL* right] returns [BaseGDL** res]
    : #(ARRAYEXPR_MFCALL
            #(dot:DOT  // struct assignment
            { 
                SizeT nDot=dot->nDot;
                auto_ptr<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
            } 
            l_dot_array_expr[ aD.get()] 
            (tag_array_expr[ aD.get()] /* nDot times*/ )+ 
            )         
        )
        {
            if( right == NULL)
            throw GDLException( _t, 
                                "Struct expression not allowed in this context.",
                                true,false);
            
            aD->Assign( right);

            res=NULL;
        }
    ;

// function call can be l_values (within (#EXPR ...) only)
l_arrayexpr_mfcall_as_mfcall returns[ BaseGDL** res]
{ 
    // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
    StackGuard<EnvStackT> guard(callStack);
    BaseGDL *self;
    EnvUDT*   newEnv;
}
    : #(ARRAYEXPR_MFCALL
                {
                    _t = _t->getNextSibling(); // skip DOT
                }
 
                self=expr mp2:IDENTIFIER
                {  
                    auto_ptr<BaseGDL> self_guard(self);
                    
                    newEnv=new EnvUDT( self, mp2, "", true);

                    self_guard.release();
                }
                parameter_def[ newEnv]
        )
        {
            // push environment onto call stack
            callStack.push_back(newEnv);
            
            // make the call
            res=call_lfun(static_cast<DSubUD*>(
                    newEnv->GetPro())->GetTree());
        }   
	;	

// function call can be l_values (within (#EXPR ...) only)
l_function_call returns[ BaseGDL** res]
{ 
    // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
    StackGuard<EnvStackT> guard(callStack);
    BaseGDL *self;
    BaseGDL *libRes;
    EnvUDT*   newEnv;
}

	: #(fl:FCALL_LIB //fl:IDENTIFIER
            {
                EnvT* newEnv=new EnvT( fl, fl->libFun);//libFunList[fl->funIx]);
            }
            parameter_def[ newEnv]
            {
                EnvT* callerEnv = static_cast<EnvT*>(callStack.back());
                // push id.pro onto call stack
                callStack.push_back(newEnv);
                // make the call
                BaseGDL* libRes = 
                static_cast<DLibFun*>(newEnv->GetPro())->Fun()(newEnv);
                
                res = callerEnv->GetPtrTo( libRes);
                if( res == NULL)
                throw GDLException( _t, "Library function must return a "
                    "l-value in this context: "+fl->getText());
            }
        )
    |
        (
        ( #(MFCALL 
                self=expr mp:IDENTIFIER
                {  
                    auto_ptr<BaseGDL> self_guard(self);
                    
                    newEnv=new EnvUDT( self, mp, "", true);

                    self_guard.release();
                }
                parameter_def[ newEnv]
            )
        | #(MFCALL_PARENT 
                self=expr parent:IDENTIFIER p:IDENTIFIER
                {
                    auto_ptr<BaseGDL> self_guard(self);
                    
                    newEnv=new EnvUDT( self, p,
                        parent->getText(), true);

                    self_guard.release();
                }
                parameter_def[ newEnv]
            )

        | #(f:FCALL //f:IDENTIFIER
                {
                    SetFunIx( f);
                    
                    newEnv=new EnvUDT( f, funList[f->funIx], true);
                }
                parameter_def[ newEnv]
            )
        )
        {
            // push environment onto call stack
            callStack.push_back(newEnv);
            
            // make the call
            res=call_lfun(static_cast<DSubUD*>(
                    newEnv->GetPro())->GetTree());
        }   
        )
	;	

ref_parameter returns[ BaseGDL** ret]
{
	assert(_t != NULL);

		if ( _t->getType() == DEREF) {
			//ret=
            return l_deref(_t);
// 			_t = _retTree;
		}
		else	
		//case VAR:
		//case VARPTR:
		{
			//ret=
            return l_simple_var(_t);
// 			_t = _retTree;
		}

//  	_retTree = _t;
// 	return ret;
}
    : ret=l_simple_var
    | ret=l_deref
    ;

// the environment must be on the callstack
parameter_def [EnvBaseT* actEnv] 
{
    auto_ptr<EnvBaseT> guard(actEnv); 
    try{

        _retTree = _t;
        while(_retTree != NULL) {
            static_cast<ParameterNode*>(_retTree)->Parameter( actEnv);
        }    

        actEnv->Extra(); // expand _EXTRA
        
    } 
    catch( GDLException& e)
        {
            // update line number, currently set to caller->CallingNode()
            // because actEnv is not on the stack yet, 
            // report caller->Pro()'s name is ok, because we are not inside
            // the call yet
            e.SetErrorNodeP( actEnv->CallingNode());
            throw e;
        }

	guard.release();
	
    return;

//     BaseGDL*  kval = NULL;
//     BaseGDL*  pval;
//     BaseGDL** kvalRef;
//     BaseGDL** pvalRef;

// // 	while(_t != NULL) {
// // 		switch ( _t->getType()) {
// // 		case KEYDEF_REF:
// // 		{
// // 			ProgNodeP __t160 = _t;

// // // 			match(antlr::RefAST(_t),KEYDEF_REF);
// // 			_t = _t->getFirstChild();
// // 			knameR = _t;
// // // 			match(antlr::RefAST(_t),IDENTIFIER);
// // 			_t = _t->getNextSibling();
// // 			kvalRef=ref_parameter(_t);
// // 			_t = _retTree;
// // 			// pass reference
// // 			actEnv->SetKeyword( knameR->getText(), kvalRef); 
			
// // 			_t = __t160;
// // 			_t = _t->getNextSibling();
// // 			break;
// // 		}
// // 		case KEYDEF_REF_EXPR:
// // 		{
// // 			ProgNodeP __t161 = _t;

// // // 			match(antlr::RefAST(_t),KEYDEF_REF_EXPR);
// // 			_t = _t->getFirstChild();
// // 			knameE = _t;
// // // 			match(antlr::RefAST(_t),IDENTIFIER);
// // 			_t = _t->getNextSibling();
// // 			kval=expr(_t);
// // 			_t = _retTree;
// // 			kvalRef=ref_parameter(_t);
// // 			_t = _retTree;
// // 			// pass reference
// // 			delete kval;
// // 			actEnv->SetKeyword( knameE->getText(), kvalRef); 
			
// // 			_t = __t161;
// // 			_t = _t->getNextSibling();
// // 			break;
// // 		}
// // 		case KEYDEF:
// // 		{
// // 			ProgNodeP __t162 = _t;

// // // 			match(antlr::RefAST(_t),KEYDEF);
// // 			_t = _t->getFirstChild();
// // 			kname = _t;
// // // 			match(antlr::RefAST(_t),IDENTIFIER);
// // 			_t = _t->getNextSibling();
// // 			kval=expr(_t);
// // 			_t = _retTree;
// // 			// pass value
// // 			actEnv->SetKeyword( kname->getText(), kval);
			
// // 			_t = __t162;
// // 			_t = _t->getNextSibling();
// // 			break;
// // 		}
// // 		case REF:
// // 		{
// // 			ProgNodeP __t163 = _t;

// // // 			match(antlr::RefAST(_t),REF);
// // 			_t = _t->getFirstChild();
// // 			pvalRef=ref_parameter(_t);
// // 			_t = _retTree;
// // 			// pass reference
// // 			actEnv->SetNextPar(pvalRef); 
			
// // 			_t = __t163;
// // 			_t = _t->getNextSibling();
// // 			break;
// // 		}
// // 		case REF_EXPR:
// // 		{
// // 			ProgNodeP __t164 = _t;

// // // 			match(antlr::RefAST(_t),REF_EXPR);
// // 			_t = _t->getFirstChild();
// // 			pval=expr(_t);
// // 			_t = _retTree;
// // 			pvalRef=ref_parameter(_t);
// // 			_t = _retTree;
// // 			// pass reference
// // 			delete pval;
// // 			actEnv->SetNextPar(pvalRef); 
			
// // 			_t = __t164;
// // 			_t = _t->getNextSibling();
// // 			break;
// // 		}
// //  		case KEYDEF_REF_CHECK:
// // 		{
// // 			ProgNodeP __t165 = _t;

// // // 			match(antlr::RefAST(_t),KEYDEF_REF_CHECK);
// // 			_t = _t->getFirstChild();
// // 			knameCk = _t;
// // // 			match(antlr::RefAST(_t),IDENTIFIER);
// // 			_t = _t->getNextSibling();
// // 			kval=check_expr(_t);
// // 			_t = _retTree;
			
// // 			kvalRef = callStack.back()->GetPtrTo( kval);
// // 			if( kvalRef != NULL)
// // 			{   // pass reference
// // 			actEnv->SetKeyword(knameCk->getText(), kvalRef); 
// // 			}
// // 			else 
// // 			{   // pass value
// // 			actEnv->SetKeyword(knameCk->getText(), kval); 
// // 			}
			
// // 			_t = __t165;
// // 			_t = _t->getNextSibling();
// // 			break;
// // 		}
// // 		case REF_CHECK:
// // 		{
// // 			ProgNodeP __t166 = _t;

// // // 			match(antlr::RefAST(_t),REF_CHECK);
// // 			_t = _t->getFirstChild();
// // 			pval=check_expr(_t);
// // 			_t = _retTree;
			
// // 			pvalRef = callStack.back()->GetPtrTo( pval);
// // 			if( pvalRef != NULL)
// // 			{   // pass reference
// // 			actEnv->SetNextPar( pvalRef); 
// // 			}
// // 			else 
// // 			{   // pass value
// // 			actEnv->SetNextPar( pval); 
// // 			}
			
// // 			_t = __t166;
// // 			_t = _t->getNextSibling();
// // 			break;
// // 		}
// // 		default:
// // 		{
// // 			pval=expr(_t);
// //  			_t = _retTree;
			
// // 			// pass value
// // 			actEnv->SetNextPar(pval); 
			
// // 			break;
// // 		}

// // 		} // switch
// //     } // while

	
// // 	actEnv->Extra(); // expand _EXTRA
// // 	guard.release();
	
// // 	_retTree = _t;

// //     return;
}
    : (  #(KEYDEF_REF IDENTIFIER //ref_parameter
//                 {   // pass reference
//                     actEnv->SetKeyword( knameR->getText(), kvalRef); 
//                 }
            )
//         | #(KEYDEF_REF_EXPR IDENTIFIER 
//                 // execute ++ and assignment
//                 //expr 
//                 //ref_parameter
// //                 {   // pass reference
// //                     delete kval;
// //                     actEnv->SetKeyword( knameE->getText(), kvalRef); 
// //                 }
//             )
//         | #(KEYDEF IDENTIFIER //expr
// //                 {   // pass value
// //                     actEnv->SetKeyword( kname->getText(), kval);
// //                 }
//             )
//         | #(REF ref_parameter
// //                 {   // pass reference
// //                     actEnv->SetNextPar(pvalRef); 
// //                 }   
//             )
//         | #(REF_EXPR 
//                 // execute ++ and assignment
//                 //expr 
//                 //ref_parameter
// //                 {   // pass reference
// //                     delete pval;
// //                     actEnv->SetNextPar(pvalRef); 
// //                 }   
//             )
//         | //expr
// //             {  
// //                 // pass value
// //                 actEnv->SetNextPar(pval); 
// //             }
//         | #(KEYDEF_REF_CHECK IDENTIFIER 
//                 //check_expr
// //                 {
// //                     kvalRef = callStack.back()->GetPtrTo( kval);
// //                     if( kvalRef != NULL)
// //                     {   // pass reference
// //                         actEnv->SetKeyword(knameCk->getText(), kvalRef); 
// //                     }
// //                     else 
// //                     {   // pass value
// //                         actEnv->SetKeyword(knameCk->getText(), kval); 
// //                     }
// //                 }
//             )   
//         | #(REF_CHECK
//                 //check_expr
// //                 {
// //                     pvalRef = callStack.back()->GetPtrTo( pval);
// //                     if( pvalRef != NULL)
// //                     {   // pass reference
// //                         actEnv->SetNextPar( pvalRef); 
// //                     }
// //                     else 
// //                     {   // pass value
// //                         actEnv->SetNextPar( pval); 
// //                     }
// //                 }       
//             )
        )*             
//         {
//             actEnv->Extra(); // expand _EXTRA
//             guard.release();
//         }
	;

arrayindex_list returns [ArrayIndexListT* aL]
{
    ExprListT        exprList; // for cleanup
    IxExprListT      ixExprList;
    SizeT nExpr;
    BaseGDL* s;

	
	ProgNodeP retTree = _t->getNextSibling();
	ax = _t;
// 	match(antlr::RefAST(_t),ARRAYIX);
	_t = _t->getFirstChild();
	
	aL = ax->arrIxList;
	assert( aL != NULL);
	
	nExpr = aL->NParam();
	if( nExpr == 0)
	{
	aL->Init();
	_retTree = retTree;
	return aL;
	}
	
	while( _t != NULL) {

			switch ( _t->getType()) {
			case CONSTANT:
			case DEREF:
			case SYSVAR:
			case VAR:
			case VARPTR:
			{
				s=indexable_expr(_t);
				_t = _retTree;
				break;
			}
			case FCALL_LIB:
			{
				s=check_expr(_t);
				_t = _retTree;
				
				if( !callStack.back()->Contains( s)) 
				exprList.push_back( s);
				
				break;
			}
			default:
			{
				s=indexable_tmp_expr(_t);
				_t = _retTree;
				exprList.push_back( s);
				break;
			}
			} // switch
			
			
			ixExprList.push_back( s);
			if( ixExprList.size() == nExpr)
                break; // allows some manual tuning
	}

	aL->Init( ixExprList);
	
	_retTree = retTree;
	return aL;
}
	: #(ax:ARRAYIX
//             {
//                 aL = ax->arrIxList;
//                 assert( aL != NULL);

//                 nExpr = aL->NParam();
//                 if( nExpr == 0)
//                 {
//                     aL->Init();
//                     goto empty;
//                 }

// //                 if( nExpr > 1)
// //                 {
// //                     ixExprList.reserve( nExpr);
// //                     exprList.reserve( nExpr);
// //                 }
// //                if( nExpr == 0) goto empty;
//             }
            (
                ( s=indexable_expr
                | s=check_expr
                    {
                        if( !callStack.back()->Contains( s)) 
                        exprList.push_back( s);
                    }
                | s=indexable_tmp_expr { exprList.push_back( s);}
                )
//                 {
//                     ixExprList.push_back( s);
//                     if( ixExprList.size() == nExpr)
//                         break; // allows some manual tuning
//                 }
            )*
//            { empty: ;}
        )
//         {
//             aL->Init( ixExprList);
//             empty:
//         }
    ;

// // and array_def is a primary expression
// array_def returns [BaseGDL* res]
// {
//     DType  cType=UNDEF; // conversion type
//     SizeT maxRank=0;
//     BaseGDL* e;
//     ExprListT          exprList;
//     BaseGDL*           cTypeData;
// }
//     : #(a:ARRAYDEF 
//             (e=expr
//                 {
//                     // add first (this way it will get cleaned up anyway)
//                     exprList.push_back(e);
                    
//                     DType ty=e->Type();
//                     if( ty == UNDEF)
//                     {
//                         throw GDLException( _t, "Variable is undefined: "+
//                             Name(e));
//                     }
//                     if( cType == UNDEF) 
//                     {
//                         cType=ty;
//                         cTypeData=e;
//                     }
//                     else 
//                     { 
//                         if( cType != ty) 
//                         {
//                             if( DTypeOrder[ty] > 100 || DTypeOrder[cType] > 100) // struct, ptr, object
//                             {
//                                 throw 
//                                 GDLException( _t, e->TypeStr()+
//                                     " is not allowed in this context.");
//                             }
                            
//                             // update order if larger type (or types are equal)
//                             if( DTypeOrder[ty] >= DTypeOrder[cType]) 
//                             {
//                                 cType=ty;
//                                 cTypeData=e;
//                             }
//                         }
//                         if( ty == STRUCT)
//                         {
//                             // check for struct compatibility
//                             DStructDesc* newS=
//                             static_cast<DStructGDL*>(e)->Desc();
//                             DStructDesc* oldS=
//                             static_cast<DStructGDL*>(cTypeData)->Desc();

//                             // *** here (*newS) != (*oldS) must be set when
//                             // unnamed structs not in struct list anymore
//                             // WRONG! This speeds up things for named structs
//                             // unnamed structs all have their own desc
//                             // and thus the next is always true for them
//                             if( newS != oldS)
//                             {
// //                                 if( (*newS) == (*oldS))
// //                                 {
// // Not needed, CatArray puts the right descriptor
// //                                     // different structs with same layout
// //                                     // replace desc with first one
// //                                     if( oldS->IsUnnamed())
// //                                         oldS = new DStructDesc( oldS);

// //                                     static_cast<DStructGDL*>(e)->SetDesc( oldS);
// //                                 }
// //                                 else

//                                 if( (*newS) != (*oldS))
//                                     throw GDLException( _t, 
//                                         "Conflicting data structures: "+
//                                         Name(cTypeData)+", "+Name(e));
//                             }
//                         }
//                     }

//                     // memorize maximum Rank
//                     SizeT rank=e->Rank();
//                     if( rank > maxRank) maxRank=rank;
//                 }
//             )+
//         )
//         {  
//             res=cTypeData->CatArray(exprList,a->arrayDepth,maxRank);
//         }
//   ;


// named_struct_def returns[ BaseGDL* res]
// {
//     DStructDesc*          nStructDesc;
//     auto_ptr<DStructDesc> nStructDescGuard;
//     BaseGDL* e;
//     BaseGDL* ee;
// }
// 	: #(n:NSTRUC id:IDENTIFIER 
//             {
//                 // definedStruct: no tags present
//                 if( n->definedStruct == 1) GetStruct( id->getText(), _t);

//                 // find struct 'id' (for compatibility check)
//                 DStructDesc* oStructDesc=
//                 FindInStructList( structList, id->getText());
                
//                 if( oStructDesc == NULL || oStructDesc->NTags() > 0)
//                 {
//                     // not defined at all yet (-> define now)
//                     // or completely defined  (-> define now and check equality)
//                     nStructDesc= new DStructDesc( id->getText());
                    
//                     // guard it
//                     nStructDescGuard.reset( nStructDesc); 
//                 } 
//                 else
//                 {   // NTags() == 0
//                     // not completely defined (only name in list)
//                     nStructDesc= oStructDesc;
//                 }
                
//                 // the instance variable
// //                 DStructGDL* instance= new DStructGDL( nStructDesc,
// //                                                       dimension(1)); 
//                 DStructGDL* instance= new DStructGDL( nStructDesc);

//                 auto_ptr<DStructGDL> instance_guard(instance);
//             }

//             // PROBLEM: both the descriptor AND the instance must be defined
//             ( ee=expr
//                 {
//                     // also adds to descriptor, grabs
//                     instance->NewTag( 
//                         oStructDesc->TagName( nStructDesc->NTags()),
//                         ee);
//                 }
//             | i:IDENTIFIER e=expr // e is a new BaseGDL*
//                 {
//                     // also adds to descriptor, grabs
//                     instance->NewTag( i->getText(), e); 
//                 }
//             | INHERITS ii:IDENTIFIER
//             // INHERITS triggers read/compile/interpret of 
//             // IDENTIFIER__define.pro
//             // if the struct named IDENTIFIER is not already known
//                 {
//                     DStructDesc* inherit=GetStruct( ii->getText(), _t);

//                     //   nStructDesc->AddParent( inherit);
//                     instance->AddParent( inherit);
//                 }
                
//             )+
       
//             {
//                 // inherit refers to nStructDesc, in case of error both have to
//                 // be freed here
//                 if( oStructDesc != NULL)
//                 {
//                     if( oStructDesc != nStructDesc)
//                     {
//                         oStructDesc->AssureIdentical(nStructDesc);
//                         instance->DStructGDL::SetDesc(oStructDesc);
//                         //delete nStructDesc; // auto_ptr
//                     }
//                 }
//                 else
//                 {
//                     // release from guard (if not NULL)
//                     nStructDescGuard.release();

//                     // insert into struct list 
//                     structList.push_back(nStructDesc);
//                 }
                
//                 instance_guard.release();
//                 res=instance;
//             }
//         )
//     ;

// unnamed_struct_def returns[ BaseGDL* res]
// {
//     // don't forget the struct in extrat.cpp if you change something here
//     // "$" as first char in the name is necessary 
//     // as it defines unnnamed structs (see dstructdesc.hpp)
//     DStructDesc*   nStructDesc = new DStructDesc( "$truct");

//     // instance takes care of nStructDesc since it is unnamed
// //     DStructGDL* instance = new DStructGDL( nStructDesc, dimension(1));
//     DStructGDL* instance = new DStructGDL( nStructDesc);
//     auto_ptr<DStructGDL> instance_guard(instance);

//     BaseGDL* e;
// }
// 	: #(STRUC 
//             ( si:IDENTIFIER e=expr
//                 {
//                     // also adds to descriptor, grabs
//                     instance->NewTag( si->getText(), e); 
//                 }
//             )+
            
//             {
// //                 DStructDesc* oStructDesc=nStructDesc->FindEqual( structList);
// //                 if( oStructDesc != NULL)
// //                 {
// //                     instance->SetDesc(oStructDesc);
// //                     //delete nStructDesc; // auto_ptr
// //                 }
// //                 else
// //                 {
// //                     // insert into struct list
// //                     structList.push_back( nStructDesc.release());
// //                 }
                
//                 instance_guard.release();
//                 res=instance;
//             }
//         )
//     ;

// // only from named structs
// struct_def returns[ BaseGDL* res]
//     : res=named_struct_def
//     | res=unnamed_struct_def
// 	| #(NSTRUC_REF idRef:IDENTIFIER 
//             {
//                 // find struct 'id'
//                 // returns it or throws an exception
//                 DStructDesc* dStruct=GetStruct( idRef->getText(), _t);
                
//                 res=new DStructGDL( dStruct, dimension(1));
//             }
//         )
// 	;
